<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go语言期末复习笔记</title>
      <link href="/post/3f22f381.html"/>
      <url>/post/3f22f381.html</url>
      
        <content type="html"><![CDATA[<h1 id="go语言期末复习笔记"><a href="#go语言期末复习笔记" class="headerlink" title="go语言期末复习笔记"></a>go语言期末复习笔记</h1><h2 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h2><p>1.变量声明</p><p>声明一个整型变量i__________var i int</p><p>2.声明数组</p><p>声明一个含有10个元素的整型数组a__________var a [10]int</p><p>3.指针变量声明</p><p>声明一个整型指针变量p__________var p *int</p><p>4.map声明</p><p>声明一个key为字符串型value为整型的map变量m__________var m map[string]int</p><h2 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h2><p>1.关于函数声明,下面语法错误的是。C</p><p>A.func f(a,b int) (value int, err error)    B.func f(a int,b int) (value int, err error)</p><p>C.func f(a,b int) (value int, error)           D.func f(a int,b int) (int, error)</p><p>2.golang中的引用类型不包括。B</p><p>A.map      B.数组      C.channel      D.interface</p><p>3.关于select机制,下面说法不正确的是()。D</p><p>A.select用来处理异步IO问题</p><p>B.select机制最大的一条限制就是每个case语句里必须是一个IO操作</p><p>C.golang在语言级别支持select关键字</p><p>D.select关键字的用法与switch语句非常类似,后面要带判断条件</p><p>4.以下哪个不属于Go的关键字。D</p><p>A.break      B.func      C.struct      D.channel</p><p>5.关于变量的声明,以下错误的是。B</p><p>A.var name &#x3D; “fmt”      B.var name,sex int&#x3D; “明明”,19</p><p>C.var name string &#x3D; “红红”      D.name :&#x3D; “明明”</p><p>6.下列关于数组声明中错误的是。B</p><p>A.var arr0 [5]int &#x3D; [5]int{1, 2, 3}      B.var arr1 &#x3D; []int{1, 2, 3, 4, 5}</p><p>C.var arr2 &#x3D; […]int{1, 2, 3, 4, 5, 6}      D.var str &#x3D; [5]string{3: “hello world”, 4: “tom”}</p><p>7.下列有关数组声明的使用错误的是。D</p><p>A.<code>a := [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;</code></p><p>B.<code>var str = [5]string&#123;3: &quot;hello world&quot;, 4: &quot;tom&quot;&#125;</code></p><p>C.<code>var arr0 [5][3]int</code></p><p>D.<code>b := [...][...]int&#123;&#123;1, 1&#125;, &#123;2, 2&#125;, &#123;3, 3&#125;&#125;</code></p><p>8.b :&#x3D; 123 a :&#x3D; (b &#x2F; 10) % 10.最后a的值为。B</p><p>A.3      B.2      C.12      D.1</p><p>9.关于类型转化，下面语法正确的是（）。C</p><p>A. type MyInt int var i int &#x3D; 1 var j MyInt &#x3D; i</p><p>B. type MyInt int var i int &#x3D; 1 var j MyInt &#x3D; (MyInt)i</p><p>C. type MyInt int var i int &#x3D; 1 var j MyInt &#x3D; MyInt(i)</p><p>D. type MyInt int var i int &#x3D; 1 var j MyInt &#x3D; i.(MyInt)</p><p>在Go语言中，类型转化可以通过将值从一种类型转换为另一种类型来完成。在这个选项中，使用了类型转化操作符<code>MyInt(i)</code>将<code>i</code>从<code>int</code>类型转换为<code>MyInt</code>类型，然后将结果赋值给<code>j</code>。</p><p>其他选项中存在语法错误或不合法的类型转化操作：</p><ul><li>选项A中，<code>i</code>是<code>int</code>类型，无法直接赋值给<code>MyInt</code>类型的变量<code>j</code>。</li><li>选项B中，类型转化语法错误，应该使用<code>MyInt(i)</code>而不是<code>(MyInt)i</code>。</li><li>选项D中，<code>.()</code>语法用于类型断言，而不是类型转化，因此是错误的语法。</li></ul><p>10.下面的程序的运行结果是（）。C</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.321      B.32      C.31      D.13</p><p>1.从切片中删除一个元素，下面的算法实现正确的是（）。D</p><p>A.func (s *Slice)Remove(value interface{}) error { for i, v :&#x3D; range *s { if isEqual(value, v) { if i&#x3D;&#x3D; len(*s) - 1 { *s &#x3D; (*s)[:i] }else { *s &#x3D; append((*s)[:i],(*s)[i + 2:]…) } return nil } } return ERR_ELEM_NT_EXIST }</p><p>B.func (s *Slice)Remove(value interface{}) error { for i, v :&#x3D; range *s { if isEqual(value, v) { *s &#x3D; append((*s)[:i],(*s)[i + 1:]) return nil } } return ERR_ELEM_NT_EXIST }</p><p>C.func (s *Slice)Remove(value interface{}) error { for i, v :&#x3D; range *s { if isEqual(value, v) { delete(*s, v) return nil } } return ERR_ELEM_NT_EXIST }</p><p>D.func (s *Slice)Remove(value interface{}) error { for i, v :&#x3D; range *s { if isEqual(value, v) { *s &#x3D; append((*s)[:i],(*s)[i + 1:]…) return nil } } return ERR_ELEM_NT_EXIST }</p><p>2.如果Add函数的调用代码为：。A</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a Integer = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> b Integer = <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line">        sum := i.(Integer).Add(b)</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. type Integer int func (a Integer) Add(b Integer) Integer { return a + b }</p><p>B. type Integer int func (a Integer) Add(b *Integer) Integer { return a + *b }</p><p>C.type Integer int func (a *Integer) Add(b Integer) Integer { return *a + b }</p><p>D. type Integer int func (a *Integer) Add(b *Integer) Integer { return *a + *b }</p><p>3.关于无缓冲和有冲突的channel，下面说法正确的是（）。D</p><p>A.无缓冲的channel是默认的缓冲为1的channel</p><p>B.无缓冲的channel和有缓冲的channel都是同步的</p><p>C.无缓冲的channel和有缓冲的channel都是非同步的</p><p>D.无缓冲的channel是同步的，而有缓冲的channel是非同步的</p><p>4.关于map，下面说法正确的是（）。A</p><p>A.map反序列化时json.unmarshal的入参必须为map的地址</p><p>B.在函数调用中传递map，则子函数中对map元素的增加不会导致父函数中map的修改</p><p>C.在函数调用中传递map，则子函数中对map元素的修改不会导致父函数中map的修改</p><p>D.不能使用内置函数delete删除map的元素</p><p>5.以下标识符命名不正确的是。D</p><p>A.mahesh        B.a_123          C._crash        D.defer</p><p>6.下面关于标识符的命名,正确的是。C</p><p>A.switch         B.a+b       C.move_name        D.3sa</p><p>7.关于Go 中切片的特性 下列说明正确的是：。A</p><p>A.一个空切片长度和容量都是0，并且不存在底层数组</p><p>B.每次调用 append 时都会创建一个新的切片值</p><p>C.在容量增长的时候每次都将容量翻倍</p><p>D.将切片赋值给其它变量，会创建一个新的切片值</p><p>8.下面关于Go语言中goroutine的描述中，正确的是：。C</p><p>A.goroutine是由操作系统调度的线程</p><p>B.goroutine的栈大小是固定的</p><p>C.goroutine可以通过channel来同步和通信</p><p>D.goroutine可以通过mutex来实现互斥访问</p><p>9.下面关于Go语言中接口的描述中，正确的是：。D</p><p>A.接口类型可以被实例化</p><p>B.接口类型可以包含私有成员</p><p>C.实现接口时，必须显式声明实现了哪些接口</p><p>D.实现接口时，必须实现接口中所有的方法</p><p>10.关于Go语言中的defer语句，以下描述正确的是：。B</p><p>A.defer语句必须在函数的最后一行执行</p><p>B.defer语句可以用于关闭文件、释放资源等操作</p><p>C.defer语句可以使用闭包访问外部变量</p><p>D.在defer语句中修改返回值不会影响函数的返回值</p><p>1.下面关于Go语言中的struct的描述中，正确的是：。C</p><p>A.struct可以继承其他struct              B.struct的字段可以是函数类型</p><p>C.struct的字段可以是切片类型         D.struct的字段可以是接口类型</p><p>2.下面关于Go语言中的错误处理的描述中，正确的是。D</p><p>A.在函数中返回错误时，通常需要将错误信息输出到控制台</p><p>B.在函数中返回错误时，应该使用panic</p><p>C.在函数中返回错误时，应该使用log来记录错误信息</p><p>D.在函数中返回错误时，应该将错误信息封装在error类型中返回</p><p>3.下面关于Go语言中的数组和切片的描述中，正确的是：。C</p><p>A.数组和切片都是引用类型</p><p>B.数组和切片都可以动态增长</p><p>C.数组的长度是固定的，切片的长度是可变的</p><p>D.数组和切片的元素类型必须相同</p><p>4.设有说明语句如下; 关于c,d 的取值正确的是。D</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span> </span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>  </span><br><span class="line">c := (a &amp;&amp; b) &amp;&amp; (!b) </span><br><span class="line">d := (a || b) &amp;&amp; (!a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A.true;true        B.true;false</p><p>C.false;false      D.false;true</p><p>5.关于类型转化，下面语法不正确的是（）。D</p><p>A.type MyInt int var i int &#x3D; 1 var jMyInt &#x3D; i</p><p>B.type MyIntint var i int&#x3D; 1 var jMyInt &#x3D; (MyInt)i</p><p>C.type MyIntint var i int&#x3D; 1 var jMyInt &#x3D; MyInt(i)</p><p>D.type MyIntint var i int&#x3D; 1 var jMyInt &#x3D; i.(MyInt)</p><p>6.下面哪个函数可以将字符串转换为整数？。A</p><p>A.strconv.Atoi()                    B.strconv.Itoa()</p><p>C.strconv.ParseBool()         D. strconv.ParseFloat()</p><p>7.下面哪个不是 Golang 的控制语句？。D</p><p>A.if             B.switch             C.for           D.continue</p><p>8.下面哪个语句可以创建一个新的 Goroutine？。A</p><p>A.go myFunction()                                       B.newGoroutine(myFunction())</p><p>C.startGoroutine(myFunction())                D. createGoroutine(myFunction())</p><p>9.下面哪个包提供了 Golang 中的并发功能？。A</p><p>A.sync            B.io              C.time              D.fmt</p><p>10.Golang 中的包（package）是指什么？。A</p><p>A.一组相关的变量和函数              B.一个可执行的程序</p><p>C.一组关联的数据结构                  D. 一段程序代码</p><p>1.下面哪些场景不适合使用 Golang 的 channel 进行通信？。C</p><p>A. 线程间通信             B.进程间通信              C.任务调度            D.事件驱动</p><p>2.下列哪种关键字可以用于声明 Golang 中的常量？。B</p><p>A.var                   B.const                 C.let               D.def</p><p>3.下面哪个函数可以用于从标准输入读取一行字符串？。C</p><p>A.fmt.Scanf()                            B. fmt.Scan()</p><p>C.bufio.NewReader()              D.bufio.ReadLine()</p><p>4.关于 Go 语言切片（slice）的描述，哪个选项是正确的？。A</p><p>A.切片是数组的引用类型            B.切片的长度是固定的</p><p>C.切片不能增加或减少元素        D.切片的容量不能改变</p><p>5.关于 Go 语言接口（interface）的描述，哪个选项是不正确的？。C</p><p>A.接口可以嵌套其他接口            B.接口只能包含方法定义，不能包含变量</p><p>C.接口可以实现具体的方法        D.接口不能被实例化</p><p>6.下面哪个语句可以用来从一个通道中读取数据，同时判断通道是否已经关闭？。D</p><p>A.val :&#x3D; &lt;-ch               B.&lt;-ch                  C.close(ch)                 D.val, ok :&#x3D; &lt;-ch</p><p>7.下面程序会输出什么？。A</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0 1 2 3 4 5 6 7 8 9                        B.1 2 3 4 5 6 7 8 9 10</p><p>C.0 1 2 3 4 5 6 7 8 9 10                  D.程序会死锁</p><p>8.下面哪个关键字可以用来定义一个匿名字段？。C</p><p>A.field               B.type              C.struct            D.anonymous</p><p>9.下面哪个方法可以用来创建一个新的缓冲区？。D</p><p>A.bufio.NewWriter()              B.bufio.NewReader()</p><p>C.bufio.NewScanner()           D.bufio.NewBuffer()</p><p>10.下面哪个函数可以用来在通道上进行非阻塞的读写操作？。D</p><p>A.close()                B.len()                C.cap()               D.select()</p><p>1.下面程序输出什么。C</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">v := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;Received value:&quot;</span>, v)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">v := <span class="number">42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sending value:&quot;</span>, v)</span><br><span class="line">ch &lt;- v</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Sending value: 42                                                       B.Received value: 42</p><p>C.Sending value: 42 Received value: 42                     D.程序会一直阻塞</p><p>2.下面程序输出什么？。C</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">v := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;Received value:&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Sending value:&quot;</span>, i)</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. Sending value: 0 1 2 3 4 Received value: 0 1 2 3 4</p><p>B. Received value: 0 1 2 3 4 Sending value: 0 1 2 3 4</p><p>C. Sending value: 0 Received value: 0 Sending value: 1 Sending value: 2 Received value: 1 Received value: 2</p><p>D.输出结果不确定</p><p>3.以下哪个选项可以正确地使用 errors 包创建一个错误？。A</p><p>A.err :&#x3D; errors.New(“This is an error.”)</p><p>B.err :&#x3D; errors.Error(“This is an error.”)</p><p>C.err :&#x3D; errors.Create(“This is an error.”)</p><p>D.err :&#x3D; errors.Err(“This is an error.”)</p><p>4.对于局部变量整型切片x的赋值，下面定义正确的是？。B</p><p>A.x :&#x3D; []int{ 1, 2, 3, 4, 5, 6, }               B.x :&#x3D; []int{ 1, 2, 3, 4, 5, 6 }</p><p>C.x :&#x3D; []int{ 1, 2, 3, 4, 5, 6}                 D.x :&#x3D; []int{1, 2, 3, 4, 5, 6,}</p><p>5.关于channel的特性，下面说法正确的是。C</p><p>A.给一个 nil channel 发送数据，造成永远阻塞       &#x2F;&#x2F;造成panic错误</p><p>B.从一个 nil channel 接收数据，造成永远阻塞       &#x2F;&#x2F;造成panic错误</p><p>C.给一个已经关闭的 channel 发送数据，不会引起 panic</p><p>D.从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</p><p>6.关于select机制，下面说法正确的是。D</p><p>A.select机制用来处理异步IO问题</p><p>B.select机制最大的一条限制就是每个case语句里必须是一个IO操作</p><p>C.golang在语言级别支持select关键字</p><p>D.select关键字的用法与switch语句非常类似，后面要带判断条件</p><p>7.请选出代码正确的输出结果。A</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">    p2 := Person&#123;name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">30</span>&#125;</span><br><span class="line">    p3 := Person&#123;name: <span class="string">&quot;Charlie&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(p1.name, p1.age)</span><br><span class="line">    fmt.Println(p2.name, p2.age)</span><br><span class="line">    fmt.Println(p3.name, p3.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Alice 20 Bob 30 Charlie 0                   B.Alice 20 Bob 30 Charlie</p><p>C.Alice 20 Bob 30 empty 0                    D.编译错误</p><p>8.下面代码输出的正确结果是。A</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (r.width + r.height)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rect := Rectangle&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Area:&quot;</span>, rect.Area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter:&quot;</span>, rect.Perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Area: 50 Perimeter: 30               B.Area: 30 Perimeter: 50</p><p>C.编译错误                                        D.Area: 30.0 Perimeter: 50.0</p><p>9.下面程序正确的输出结果是。D</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    node.Val = node.Next.Val</span><br><span class="line">    node.Next = node.Next.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    head := &amp;ListNode&#123;Val: <span class="number">1</span>, Next: &amp;ListNode&#123;Val: <span class="number">2</span>, Next: &amp;ListNode&#123;Val: <span class="number">3</span>, Next: <span class="literal">nil</span>&#125;&#125;&#125;</span><br><span class="line">    fn(head.Next)</span><br><span class="line">    fmt.Println(head.Val, head.Next.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A.1 2</p><p>B.2 3</p><p>C.3 2</p><p>D.1 3</p><p>这段代码定义了一个简单的链表结构 <code>ListNode</code>，每个节点包含一个整数值 <code>Val</code> 和一个指向下一个节点的指针 <code>Next</code>。</p><p>接下来，代码定义了一个名为 <code>fn</code> 的函数，它接受一个指向 <code>ListNode</code> 的指针作为参数。在该函数中，它将传入节点的值更新为下一个节点的值，并将当前节点的 <code>Next</code> 指针指向下一个节点的下一个节点，相当于将当前节点从链表中移除。</p><p>在 <code>main</code> 函数中，首先创建了一个链表的头节点 <code>head</code>，它的值为 1，下一个节点为值为 2 的节点，第二个节点的下一个节点为值为 3 的节点，最后一个节点的 <code>Next</code> 指针为 <code>nil</code>，表示链表的结束。</p><p>然后，通过调用 <code>fn(head.Next)</code> 将链表的第二个节点传递给函数 <code>fn</code> 进行处理。在函数内部，被传入的节点的值被更新为下一个节点的值（即将节点 2 的值更新为节点 3 的值），并且当前节点的 <code>Next</code> 指针指向了下一个节点的下一个节点（即节点 3 的下一个节点）。</p><p>最后，在 <code>main</code> 函数中，通过打印 <code>head.Val</code> 和 <code>head.Next.Val</code>，我们可以看到链表头节点的值为 1，而它的下一个节点的值已经变为 3，因为节点 2 被移除了。</p><p>因此，这段代码的执行结果将会输出 <code>1 3</code>。</p><p>10.下面代码输出什么。C</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a1 := []<span class="type">int</span>&#123;<span class="number">10</span>&#125;</span><br><span class="line">a2 := a1[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(a2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译失败</p><p>B.panic: runtime error: index out of range [1] with length 1</p><p>C.[]</p><p>D.其他</p><p>1.下面正确的答案是。B</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> y *<span class="type">int</span> = &amp;x</span><br><span class="line">*y = <span class="number">20</span></span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.10               B.20             C.运行错误           D.编译错误</p><p>2.下面答案正确的一项是。B</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> funcs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        funcs = <span class="built_in">append</span>(funcs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(num)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.1 2 3 4 5          B.5 5 5 5 5            C.编译错误          D.1 1 1 1 1</p><p>3.关于协程，下面说法正确是。D</p><p>A.通过共享内存来实现通信                B.线程比协程更轻量级</p><p>C.协程不存在死锁问题                        D.通过channel来进行协程间的通信</p><p>4.关于channel，下面语法错误的是。D</p><p>A.var ch chan int             B.ch :&#x3D; make(chan int)</p><p>C.&lt;- ch                              D.ch &lt;-</p><p>5.有关协程的说法错误的是。D</p><p>A.协程和线程都可以实现程序的并发执行</p><p>B.通过channel来进行协程间的通信</p><p>C.只需要在函数调用前添加go关键字即可实现go的协程，创建并发任务</p><p>D.协程比线程耗费资源更多一些</p><p>6.Go Modules 的主要作用是什么？。D</p><p>A.管理项目的依赖关系             B.安装和更新依赖包</p><p>C.管理项目版本号                     D.所有以上都是</p><p>7.在 Go Modules 中，如何初始化一个新的模块？。B</p><p>A.使用go get命令                         B.使用go mod init命令</p><p>C.使用go mod tidy命令               D.使用go mod vendor命令</p><p>8.Go 语言和 Java 的编译方式有何不同？。A</p><p>A.Go 语言需要先编译成二进制文件再运行</p><p>B. Java 需要先编译成二进制文件再运行</p><p>C.Go 语言可以直接运行源代码</p><p>D. Java 可以直接运行源代码</p><p>9.Gin 框架中如何实现文件上传？。A</p><p>A.使用 context.SaveUploadedFile() 函数实现</p><p>B.使用 context.PostForm() 函数实现</p><p>C.使用 context.File() 函数实现</p><p>D.以上都不是</p><p>10.Gin 框架支持哪种类型的路由？。A</p><p>A.RESTful 路由          B. RPC 路由            C.WebSocket 路由           D.全局路由</p><p>1.Gin 框架中如何实现中间件？。C</p><p>A.使用 context.Next() 函数实现               B.使用 context.Abort() 函数实现</p><p>C. 使用 gin.Use() 函数注册中间件            D.以上都可以</p><p>2.在 Go 语言中，如何向切片中添加元素？。A</p><p>A.使用 append() 函数                 B.使用 push() 函数</p><p>C. 使用 insert() 函数                   D.以上都不是</p><p>3.在 Go 语言中，如何向数组中添加元素？。D</p><p>A.使用 append() 函数              B.使用 push() 函数</p><p>C.使用 insert() 函数                 D.无法做到</p><p>4.在 Go 语言中，如何获取切片的长度和容量？。A</p><p>A.使用 len() 函数获取切片的长度，使用 cap() 函数获取切片的容量</p><p>B.使用 length() 函数获取切片的长度，使用 capacity() 函数获取切片的容量</p><p>C.使用 size() 函数获取切片的长度和容量</p><p>D.以上都不是</p><p>5.在 Go 语言中，如果一个无缓冲 channel 中没有数据可读，会发生什么？。B</p><p>A.发送操作会被阻塞                  B.接收操作会被阻塞</p><p>C.以上都会被阻塞                      D.不会被阻塞</p><p>6.在 Go 语言中，如何创建一个有缓冲的 channel？。A</p><p>A.make(chan T, n)                B.make(chan T, 0)</p><p>C.以上都可以                         D.都不可以</p><p>7.在 Go 语言中，如何使用互斥锁？。D</p><p>A.使用 sync.Mutex 类型                   B.使用 mutex() 函数</p><p>C.使用 lock() 和 unlock() 方法          D.以上都是</p><p>8.在 Go 语言中，如何使用 select 语句？。A</p><p>A.用于等待多个 channel 中的数据到达</p><p>B.用于等待单个 channel 中的数据到达</p><p>C.用于等待定时器到期</p><p>D.以上都是</p><p>9.在 Go 语言中，如何使用 panic 和 recover 实现异常处理？。A</p><p>A.使用 defer 语句和 panic() 函数触发 panic，使用 recover() 函数捕获 panic</p><p>B.使用 try-catch 块实现异常处理</p><p>C.使用 goto 语句实现异常处理</p><p>D.以上都不是</p><p>10.在 Go 语言中，如何使用反射？。A</p><p>A.使用 reflect 包中的类型和值函数            B.使用反射语句 ref(x)</p><p>C.使用反射类型反射函数                             D.以上都不是</p><p>1.golang中的指针运算包括（C）。</p><p>A.可以对指针进行自增或自减运算              B.可以通过“&amp;”取指针指向的数据</p><p>C.可以通过“*”取指针指向的数据                 D.可以对指针进行下标运算</p><h2 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h2><p>1.value是整型变量,下面if表达式符合编码规范的是(AC)</p><p>A.if value &#x3D;&#x3D;0           B.if value             C.if value !&#x3D; 0            D.if !value</p><p>2.关于协程,下面说法正确的是(AD)</p><p>A.协程和线程都可以实现程序的并发执行         B.线程比协程更轻量级</p><p>C.协程不存在死锁问题                                        D.可以通过channel来进行协程间的通信</p><p>3.关于字符串连接,下面语法正确的是(BD)</p><p>A.str :&#x3D; ‘abc’ + ‘123’                 B.str :&#x3D; “abc” + “123”</p><p>C.str :&#x3D; ‘abc’ + “123”               D.fmt.Sprintf(“abc%d”,123)</p><p>4.关于整形切片的初始化,下面正确的是(BCD)</p><p>A.s :&#x3D; make([]int)                   B.s :&#x3D; make([]int,0)</p><p>C.s :&#x3D; make([]int,5,10)           D.s :&#x3D; []int{1,2,3,4,5}</p><p>5.关于变量的自增和自减操作，下面语句正确的是（AD）</p><p>A.i :&#x3D; 1 i++          B.i :&#x3D; 1 j &#x3D; i++           C.i :&#x3D;1 ++i            D.i :&#x3D; 1 i–</p><p>6.关于字符串格式化符号,说法正确的是(BC)</p><p>A.%v,字符串类型显示             B.%d,整形以十进制类型显示</p><p>C.%s,字符串类型显示             D.%T,指针,十六进制显示</p><p>7.下面属于关键字的是（AC）</p><p>A.func            B.def              C.struct             D.class</p><p>8.定义一个包内全局字符串变量，下面语法正确的是(AD)</p><p>A.var str string             B.str :&#x3D; “”             C. str &#x3D; “”             D.var str &#x3D; “”</p><p>9.通过指针变量 p 访问其成员变量 name，下面语法正确的是（AB）</p><p>A.p.name                 B.(*p).name              C. (&amp;p).name             D.p-&gt;name</p><p>10.关于接口和类的说法，下面说法正确的是（ABD）</p><p>A.一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口</p><p>B.实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理</p><p>C. 类实现接口时，需要导入接口所在的包</p><p>D. 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口</p><p>3.关于init函数，下面说法正确的是（AB）</p><p>A. 一个包中，可以包含多个init函数</p><p>B.程序编译时，先执行导入包的init函数，再执行本包内的init函数</p><p>C.main包中，不能有init函数</p><p>D.init函数可以被其他函数调用</p><p>4.关于循环语句，下面说法正确的有（CD）</p><p>A.循环语句既支持for关键字，也支持while和do-while</p><p>B.关键字for的基本使用方法与C&#x2F;C++中没有任何差异</p><p>C.for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环</p><p>D. for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量</p><p>5.对于函数定义：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">            sum += arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对add函数调用正确的是（ABD）</p><p>A.add(1, 2)                          B.add(1, 3, 7)</p><p>C.add([]int{1, 2})                D.add([]int{1, 3, 7}…)</p><p>6.关于局部变量的初始化，下面正确的使用方式是（ABC）</p><p>A.var i int &#x3D; 10              B.var i &#x3D; 10              C.i :&#x3D; 10                D.i &#x3D; 10</p><p>8.下面哪些是 Golang 的特性？（多选）BCD</p><p>A. 支持面向对象编程             B.支持并发编程</p><p>C.垃圾回收机制                      D.静态类型检查</p><p>9.在 Go Modules 中，如何更新一个依赖的版本？ABD</p><p>A.手动编辑go.mod文件                   B. 使用go get命令</p><p>C.使用go mod vendor命令             D.使用go mod tidy命令</p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>1.数组是一个值类型（T）</p><p>2.使用map不需要引入任何库（T）</p><p>3.内置函数delete可以删除数组切片内的元素（F）</p><p>4.指针是基础类型（F）</p><p>5.interface{}是可以指向任意对象的Any类型（T）</p><p>6.Golang不支持自动垃圾回收（F）</p><p>7.下面代码中两个斜点之间的代码，比如json:”x”，作用是X字段在从结构体实例编码到JSON数据格式的时候，使用x作为名字，这可以看作是一种重命名的方式（T）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;</span><br><span class="line">        X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">        Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">        Z <span class="type">int</span> <span class="string">`json:&quot;z&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.通过成员变量或函数首字母的大小写来决定其作用域（T）</p><p>9.对于常量定义zero (const zero &#x3D; 0.0)，zero是浮点型常量（F）</p><p>10.对变量x的取反操作是~x（F）</p><p>1.golang支持goto语句（T）</p><p>2.匿名函数可以直接赋值给一个变量或者直接执行（T）</p><p>3.如果调用方调用了一个具有多返回值的方法，但是却不想关心其中的某个返回值，可以简单地用一个下划线“_”来跳过这个返回值，该下划线对应的变量叫匿名变量（T）</p><p>4.错误是业务过程的一部分，而异常不是（T）</p><p>5.golang虽然没有显式的提供继承语法，但是通过匿名组合实现了继承（T）</p><p>6.使用for range迭代map时每次迭代的顺序可能不一样，因为map的迭代是随机的（T）</p><p>7.import后面的最后一个元素是包名（F）</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h2 id="1-字符串变化大小写"><a href="#1-字符串变化大小写" class="headerlink" title="1.字符串变化大小写"></a>1.字符串变化大小写</h2><p>将字符串变化大小写并输出</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一行字符串，长度无上限，中间无空格</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出为一行，先将字符串转换为大写，再将字符串转化成小写，中间用空格隔开</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>CuitCBIYes!</p><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>CUITCBIYES! cuitcbiyes!</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">fmt.Scanln(&amp;str)</span><br><span class="line"></span><br><span class="line">strU := strings.ToUpper(str)</span><br><span class="line">strL := strings.ToLower(str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s %s&quot;</span>, strU, strL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-画梯形"><a href="#2-画梯形" class="headerlink" title="2.画梯形"></a>2.画梯形</h2><p>输入一个数字，根据数字画梯形</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入：</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>一个小于10的数字</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>5</p><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">********************</span><br><span class="line"> ******************</span><br><span class="line">  ****************</span><br><span class="line">   **************</span><br><span class="line">    ************</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">fmt.Scanln(&amp;n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">20</span> - i*<span class="number">2</span>; j &gt; <span class="number">0</span>; j = j - <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-输出“水仙花数”"><a href="#3-输出“水仙花数”" class="headerlink" title="3.输出“水仙花数”"></a>3.输出“水仙花数”</h2><p>输出介于a,b（含a,b，且a&lt;&#x3D;b）的所有“水仙花数”。所谓“水仙花数”是指一个数，其各位数字立方和等于该数本身。例如，153是一个“水仙花数”，因为153&#x3D;13+53+33。  </p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>100 200</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>153</p><h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>100 900</p><h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>153 </p><p>370 </p><p>371 </p><p>407</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">answer</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> bai = x % <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> shi = (x / <span class="number">10</span>) % <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> ge = (x / <span class="number">100</span>) % <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> result = math.Pow(<span class="type">float64</span>(bai), <span class="number">3</span>) + math.Pow(<span class="type">float64</span>(shi), <span class="number">3</span>) + math.Pow(<span class="type">float64</span>(ge), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">float64</span>(x) == result &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := a; i &lt; b+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> answer(i) == <span class="literal">true</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-输入三角形的三边长a、b、c-边长可以是小数-，求三角形面积area，并输出-结果保留两位小数"><a href="#4-输入三角形的三边长a、b、c-边长可以是小数-，求三角形面积area，并输出-结果保留两位小数" class="headerlink" title="4.输入三角形的三边长a、b、c(边长可以是小数)，求三角形面积area，并输出,结果保留两位小数"></a>4.输入三角形的三边长a、b、c(边长可以是小数)，求三角形面积area，并输出,结果保留两位小数</h2><p>输入三角形的三边长a、b、c(边长可以是小数)，求三角形面积area，并输出。如果输入的三边构不成三角形，应给出“data error”的信息提示。注：根据“海伦－秦九韶”公式，area＝√p(p-a)(p-b)(p-c)，其中p＝(a+b+c)&#x2F;2。编程可用素材：printf(“\nplease input triange sides:”)…、printf(“Output:\ndata error\n”)…、printf(“Output:\narea&#x3D;…\n”…。</p><h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>3 4 5</p><h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>6.00</p><h3 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>4 5 8</p><h3 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>8.18</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python复习总结2</title>
      <link href="/post/92cc9a62.html"/>
      <url>/post/92cc9a62.html</url>
      
        <content type="html"><![CDATA[<h2 id="10-Python内置的序列数据类型"><a href="#10-Python内置的序列数据类型" class="headerlink" title="10.Python内置的序列数据类型"></a>10.Python内置的序列数据类型</h2><p>序列（Sequence）是Python中的一种基本数据类型，它包括字符串（String）、列表（List）和元组（Tuple）。这些序列类型共享一些相似的特性，例如有序性、索引访问、切片操作等。</p><ol><li>字符串（String）：<ul><li>字符串是由字符组成的不可变序列。</li><li>字符串使用引号（单引号或双引号）来定义。</li><li>字符串中的字符按照顺序存储，可以通过索引访问。</li><li>字符串是不可变的，即不能修改字符串中的字符。</li><li>字符串常用于表示文本数据。</li></ul></li><li>列表（List）：<ul><li>列表是由元素组成的可变序列。</li><li>列表使用方括号 <code>[ ]</code> 来定义，元素之间使用逗号分隔。</li><li>列表中的元素按照插入的顺序存储，可以通过索引访问。</li><li>列表是可变的，可以修改、添加或删除其中的元素。</li><li>列表常用于存储一组有序的元素集合。</li></ul></li><li>元组（Tuple）：<ul><li>元组是由元素组成的不可变序列。</li><li>元组使用圆括号 <code>( )</code> 来定义，元素之间使用逗号分隔。</li><li>元组中的元素按照定义的顺序存储，可以通过索引访问。</li><li>元组是不可变的，一旦创建就不能修改其中的元素。</li><li>元组常用于保护数据的完整性，以及作为函数返回多个值的容器。</li></ul></li><li>字典（Dictionary）：<ul><li>字典是由键值对组成的无序集合。</li><li>字典使用花括号 <code>&#123; &#125;</code> 来定义，每个键值对使用冒号 <code>:</code> 分隔，键值对之间使用逗号分隔。</li><li>字典中的键与对应的值关联，通过键来访问值。</li><li>字典中的元素是无序的，即它们的顺序在字典中并不重要。</li><li>字典是可变的，可以添加、修改或删除键值对。</li><li>字典常用于通过键来查找和修改对应的值。</li></ul></li></ol><p>总结起来，字符串是不可变的字符序列，列表是可变的元素序列，元组是不可变的元素序列，字典是键值对的无序集合。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">• 元组也称之为定值表，用于存储值固定不变的值表。例如：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="comment">#输出：(1, 2, 3)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1[<span class="number">2</span>] <span class="comment">#输出：3</span></span><br><span class="line"></span><br><span class="line">• 列表也称之为表，用于存储其值可变的表。例如：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2[<span class="number">2</span>]=<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 <span class="comment">#输出：[1, 2, 4]</span></span><br><span class="line"></span><br><span class="line">• 字符串是包括若干字符的序列数据，支持序列数据的基本操作。例如：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3=<span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3[:<span class="number">5</span>] <span class="comment">#字符串前5个字符。输出：&#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line">• <span class="built_in">len</span>()、<span class="built_in">max</span>()、<span class="built_in">min</span>()，获取序列的长度、序列中元素最大值、序列中元素最小值</span><br><span class="line"><span class="built_in">sum</span>()获取列表或元组中各元素之和</span><br><span class="line">s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(s))  <span class="comment"># g</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(s))  <span class="comment"># a</span></span><br><span class="line">s2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s2))  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">t2 = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">sum</span>(t2)  <span class="comment"># typeError</span></span><br><span class="line">s = <span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="built_in">sum</span>(s)  <span class="comment"># typeError</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], []))  <span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>()函数在这里被用来连接列表，而不是进行求和操作。</span><br><span class="line">参数[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]是要连接的列表，而参数[]是初始值（一个空列表）。</span><br><span class="line">在这个例子中，初始值为空列表，所以<span class="built_in">sum</span>()函数会将两个子列表[<span class="number">1</span>, <span class="number">2</span>]和[<span class="number">3</span>, <span class="number">4</span>]连接在一起</span><br></pre></td></tr></table></figure><p><img src="https://i.imgloc.com/2023/06/13/VHJbXN.png" alt="VHJbXN.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;abcdef&#x27;</span>      &gt;&gt;&gt; t=(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>)       &gt;&gt;&gt; lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]            &gt;&gt;&gt; t[<span class="number">0</span>]                          &gt;&gt;&gt; lst[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;a&#x27;</span>                 <span class="string">&#x27;a&#x27;</span>                               <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]            &gt;&gt;&gt; t[<span class="number">1</span>]                          &gt;&gt;&gt; lst</span><br><span class="line"><span class="string">&#x27;c&#x27;</span>                 <span class="string">&#x27;e&#x27;</span>                               [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[-<span class="number">1</span>]           &gt;&gt;&gt; t[-<span class="number">1</span>]                         &gt;&gt;&gt; lst[<span class="number">2</span>]=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="string">&#x27;f&#x27;</span>                 <span class="string">&#x27;u&#x27;</span>                               &gt;&gt;&gt; lst[-<span class="number">2</span>]=<span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[-<span class="number">3</span>]           &gt;&gt;&gt; t[-<span class="number">5</span>]                         &gt;&gt;&gt; lst</span><br><span class="line"><span class="string">&#x27;d&#x27;</span>                 <span class="string">&#x27;a&#x27;</span>                               [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="序列的切片操作"><a href="#序列的切片操作" class="headerlink" title="序列的切片操作"></a>序列的切片操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;abcdef&#x27;</span>           &gt;&gt;&gt; t=(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;u&#x27;</span>)        &gt;&gt;&gt; lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">3</span>]               &gt;&gt;&gt; t[-<span class="number">2</span>:-<span class="number">1</span>]                       &gt;&gt;&gt; lst[:<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;bc&#x27;</span>                     (<span class="string">&#x27;o&#x27;</span>,)                             [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>:<span class="number">10</span>]              &gt;&gt;&gt; t[-<span class="number">2</span>:]                         &gt;&gt;&gt; lst[:<span class="number">1</span>]=[]</span><br><span class="line"><span class="string">&#x27;def&#x27;</span>                    (<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>)                         &gt;&gt;&gt; lst</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">8</span>:<span class="number">2</span>]               &gt;&gt;&gt; t[-<span class="number">99</span>:-<span class="number">5</span>]                      [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;</span>                       ()                                 &gt;&gt;&gt; lst[:<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:]                 &gt;&gt;&gt; t[-<span class="number">99</span>:-<span class="number">3</span>]                      [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;abcdef&#x27;</span>                 (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)                         &gt;&gt;&gt; lst[:<span class="number">2</span>]=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">2</span>]                &gt;&gt;&gt; t[::]                          &gt;&gt;&gt; lst[<span class="number">1</span>:]=<span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;ab&#x27;</span>                     (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>)          &gt;&gt;&gt; lst</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">2</span>]               &gt;&gt;&gt; t[<span class="number">1</span>:-<span class="number">1</span>]                        [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;ace&#x27;</span>                    (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>)                    &gt;&gt;&gt; <span class="keyword">del</span> lst[:<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>]              &gt;&gt;&gt; t[<span class="number">1</span>::<span class="number">2</span>]                        &gt;&gt;&gt; lst</span><br><span class="line"><span class="string">&#x27;fedcba&#x27;</span>                 (<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>)                         [<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="序列的比较运算操作"><a href="#序列的比较运算操作" class="headerlink" title="序列的比较运算操作"></a>序列的比较运算操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="string">&#x27;abc&#x27;</span>             &gt;&gt;&gt; t1=(<span class="number">1</span>,<span class="number">2</span>)                    &gt;&gt;&gt; s1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="string">&#x27;abc&#x27;</span>             &gt;&gt;&gt; t2=(<span class="number">1</span>,<span class="number">2</span>)                    &gt;&gt;&gt; s2=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3=<span class="string">&#x27;abcd&#x27;</span>            &gt;&gt;&gt; t3=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)                  &gt;&gt;&gt; s3=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s4=<span class="string">&#x27;cba&#x27;</span>             &gt;&gt;&gt; t4=(<span class="number">2</span>,<span class="number">1</span>)                    &gt;&gt;&gt; s4=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &gt; s4              &gt;&gt;&gt; t1 &lt; t4                     &gt;&gt;&gt; s1&lt;s2</span><br><span class="line"><span class="literal">False</span>                    <span class="literal">True</span>                            <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 &lt;= s3             &gt;&gt;&gt; t1 &lt;= t2                    &gt;&gt;&gt; s1 &lt;= s2</span><br><span class="line"><span class="literal">True</span>                     <span class="literal">True</span>                            <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2             &gt;&gt;&gt; t1==t3                      &gt;&gt;&gt; s1==s2</span><br><span class="line"><span class="literal">True</span>                     <span class="literal">False</span>                           <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 != s3             &gt;&gt;&gt; t1 !=t2                     &gt;&gt;&gt; s1!=s3</span><br><span class="line"><span class="literal">True</span>                     <span class="literal">False</span>                           <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a&#x27;</span> &gt; <span class="string">&#x27;A&#x27;</span>            &gt;&gt;&gt; t1 &gt;= t3                    &gt;&gt;&gt; s1&gt;=s3</span><br><span class="line"><span class="literal">True</span>                     <span class="literal">False</span>                           <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;a&#x27;</span> &gt;= <span class="string">&#x27;&#x27;</span>            &gt;&gt;&gt; t4 &gt; t3                     &gt;&gt;&gt; s4&gt;s3</span><br><span class="line"><span class="literal">True</span>                     <span class="literal">True</span>                            <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="序列的排序操作"><a href="#序列的排序操作" class="headerlink" title="序列的排序操作"></a>序列的排序操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="string">&#x27;axd&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(s1)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;x&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=(<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(s2)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(s2,reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3=<span class="string">&#x27;abAC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(s3, key=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="列表解析表达式"><a href="#列表解析表达式" class="headerlink" title="列表解析表达式"></a>列表解析表达式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment">#平方值</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(i,i**<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment">#序号, 平方值</span></span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">16</span>), (<span class="number">5</span>, <span class="number">25</span>), (<span class="number">6</span>, <span class="number">36</span>), (<span class="number">7</span>, <span class="number">49</span>), (<span class="number">8</span>, <span class="number">64</span>), (<span class="number">9</span>, <span class="number">81</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>] <span class="comment">#取偶数</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y, x*y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>) <span class="keyword">if</span> x&gt;=y] <span class="comment">#二重循环</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure><h3 id="列表的序列操作"><a href="#列表的序列操作" class="headerlink" title="列表的序列操作"></a>列表的序列操作</h3><p>索引访问、切片操作、连接操作、重复操作、成员关系操作、比较运算操作，</p><p>以及求列表长度、最大值、最小值等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]=<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]=[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, [], <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s[<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, [], <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>:<span class="number">3</span>]=[]  <span class="comment"># 表示删除位置为2的这个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">1</span>]=[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">2</span>]=<span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s[:<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3 id="list对象的方法-选择填空判断"><a href="#list对象的方法-选择填空判断" class="headerlink" title="list对象的方法-选择填空判断"></a>list对象的方法-选择填空判断</h3><p><img src="https://i.imgloc.com/2023/06/13/VHJjKV.png" alt="VHJjKV.png"></p><h3 id="使用tuple对象创建元组实例对象"><a href="#使用tuple对象创建元组实例对象" class="headerlink" title="使用tuple对象创建元组实例对象"></a>使用tuple对象创建元组实例对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1=<span class="built_in">tuple</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2=<span class="built_in">tuple</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3=<span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t4=<span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(t1,t2,t3,t4) <span class="comment">#输出：() (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (1, 2, 3) (0, 1, 2)</span></span><br></pre></td></tr></table></figure><h3 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>()-----------创建一个空字典</span><br><span class="line"><span class="built_in">dict</span>(**kwargs)---使用关键字参数，创建一个新的字典。此方法最紧凑</span><br><span class="line"><span class="built_in">dict</span>(mapping)----从一个字典对象创建一个新的字典，相当于复制，mapping是已经有的字典</span><br><span class="line"><span class="built_in">dict</span>(iterable)---使用序列，创建一个新的字典</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;boy&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(&#123;<span class="number">1</span>:<span class="string">&#x27;food&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;drink&#x27;</span>&#125;)</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;food&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;drink&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;1001&#x27;</span>),(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Jenny&#x27;</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;1001&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jenny&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(baidu=<span class="string">&#x27;baidu.com&#x27;</span>, google=<span class="string">&#x27;google.com&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;baidu&#x27;</span>: <span class="string">&#x27;baidu.com&#x27;</span>, <span class="string">&#x27;google&#x27;</span>: <span class="string">&#x27;google.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="字典的访问操作"><a href="#字典的访问操作" class="headerlink" title="字典的访问操作"></a>字典的访问操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d[Key]--------返回键为key的value；如果key不存在，则导致KeyError</span><br><span class="line">d[Key]=value--设置d[key]的值为value；如果key不存在，则添加键/值对</span><br><span class="line"><span class="keyword">del</span> d[Key]----删除字典元素；如果key不存在，则导致KeyError</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="number">1</span>:<span class="string">&#x27;food&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;drink&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;food&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;drink&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;food&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">3</span>]=<span class="string">&#x27;fruit&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;food&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;drink&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;fruit&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;food&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;fruit&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;pyshell#100&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">d[<span class="number">2</span>]</span><br><span class="line">KeyError: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="字典的视图对象"><a href="#字典的视图对象" class="headerlink" title="字典的视图对象"></a>字典的视图对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.key()-----返回字典d的键key的列表</span><br><span class="line">d.values()--返回字典d的值value的列表</span><br><span class="line">d.items()---返回字典d的(key,value)对的列表</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="number">1</span>:<span class="string">&#x27;food&#x27;</span>, <span class="number">2</span>:<span class="string">&#x27;drink&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;fruit&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">dict_keys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> d.keys():</span><br><span class="line"><span class="built_in">print</span>(k, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.values()</span><br><span class="line">dict_values([<span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;drink&#x27;</span>, <span class="string">&#x27;fruit&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line"><span class="built_in">print</span>(v, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">food drink fruit</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.items()</span><br><span class="line">dict_items([(<span class="number">1</span>, <span class="string">&#x27;food&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;drink&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;fruit&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;food&#x27;</span>) (<span class="number">2</span>, <span class="string">&#x27;drink&#x27;</span>) (<span class="number">3</span>, <span class="string">&#x27;fruit&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="字典对象的方法"><a href="#字典对象的方法" class="headerlink" title="字典对象的方法"></a>字典对象的方法</h3><p><img src="https://i.imgloc.com/2023/06/13/VHJIDd.png" alt="VHJIDd.png"></p><h3 id="字典示例："><a href="#字典示例：" class="headerlink" title="字典示例："></a>字典示例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">编写程序实现如下功能：找出任意字符串中只出现一次的字符，如果有多个这样的字符，请全部找出</span><br><span class="line">• s=<span class="built_in">input</span>(<span class="string">&quot;请输入一个英文字符串：&quot;</span>)</span><br><span class="line">• dict1=&#123;&#125;</span><br><span class="line">• <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">•     dict1[ch]=dict1.get(ch,<span class="number">0</span>) +<span class="number">1</span></span><br><span class="line">• list1=[k <span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items() <span class="keyword">if</span> v==<span class="number">1</span>]</span><br><span class="line">• <span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line">有字符串 “k:<span class="number">1</span>|k1:<span class="number">2</span>|k2:<span class="number">3</span>|k3:<span class="number">4</span>”，请处理成字典&#123;<span class="string">&#x27;k&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;k1&#x27;</span>:<span class="number">2</span> ,<span class="string">&#x27;k2&#x27;</span>:<span class="number">3</span> ,<span class="string">&#x27;k3&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">• str1 = <span class="string">&quot;k:1|k1:2|k2:3|k3:4&quot;</span></span><br><span class="line">• dic = &#123;&#125;</span><br><span class="line">• lst = str1.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">• <span class="keyword">for</span> l <span class="keyword">in</span> lst:</span><br><span class="line">•     lst2 = l.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">•     dic[lst2[<span class="number">0</span>]] = <span class="built_in">eval</span>(lst2[<span class="number">1</span>])</span><br><span class="line">• <span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>• 集合数据类型是<strong>没有顺序</strong>的简单对象的聚集，且<strong>集合中元素不重复</strong></p><p>• 可变集合对象（set）的定义</p><p>• {}表示空的dict，因为dict也使用花括号定义。空集为set()</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合实例</span><br><span class="line">存在三个数据集合s1、s2、s3，s1 = &#123;<span class="number">11</span>,<span class="number">34</span>,<span class="number">25</span>,<span class="number">67</span>,<span class="number">33</span>&#125;；s2=&#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">15</span>,<span class="number">66</span>,<span class="number">25</span>&#125;；s3=&#123;<span class="number">87</span>,<span class="number">63</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">76</span>&#125;，</span><br><span class="line">现在需要求得以下结果：</span><br><span class="line"><span class="number">1.</span>获取s1、s2和s3内容相同的元素列表  <span class="number">2.</span>获取s1中有，s2中没有的元素列表   <span class="number">3.</span>获取s1和s2中内容都不同的元素</span><br><span class="line">• s1 = &#123;<span class="number">11</span>,<span class="number">34</span>,<span class="number">25</span>,<span class="number">67</span>,<span class="number">33</span>&#125;</span><br><span class="line">• s2 = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">15</span>,<span class="number">66</span>,<span class="number">25</span>&#125;</span><br><span class="line">• s3 = &#123;<span class="number">87</span>,<span class="number">63</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">76</span>&#125;</span><br><span class="line">• <span class="comment">#1.获取s1、s2中和s3内容相同的元素列表</span></span><br><span class="line">• sres1 = (s1 &amp; s3)| (s2 &amp;s3) <span class="comment"># sres1=(s1 | s2) &amp; s3</span></span><br><span class="line">• <span class="built_in">print</span>(sres1)</span><br><span class="line">• <span class="comment">#2.获取s1中有，s2中没有的元素列表</span></span><br><span class="line">• sres2 = s1 - s2</span><br><span class="line">• <span class="built_in">print</span>(sres2)</span><br><span class="line">• <span class="comment">#3.获取s1和s2中内容都不同的元素</span></span><br><span class="line">• sres3 = s1 ^ s2</span><br><span class="line">• <span class="built_in">print</span>(sres3)</span><br><span class="line"></span><br><span class="line">集合实例</span><br><span class="line">存在三个数据集合s1、s2、s3，s1 = &#123;<span class="number">11</span>,<span class="number">34</span>,<span class="number">25</span>,<span class="number">67</span>,<span class="number">33</span>&#125;；s2=&#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">15</span>,<span class="number">66</span>,<span class="number">25</span>&#125;；s3=&#123;<span class="number">87</span>,<span class="number">63</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">76</span>&#125;，</span><br><span class="line">现在需要求得以下结果：</span><br><span class="line"><span class="number">4.</span>获取s1、s2、s3中都包含的元素               <span class="number">5.</span>获取s1、s2、s3中，只出现一次的元素</span><br><span class="line">• s1 = &#123;<span class="number">11</span>,<span class="number">34</span>,<span class="number">25</span>,<span class="number">67</span>,<span class="number">33</span>&#125;</span><br><span class="line">• s2 = &#123;<span class="number">22</span>,<span class="number">33</span>,<span class="number">15</span>,<span class="number">66</span>,<span class="number">25</span>&#125;</span><br><span class="line">• s3 = &#123;<span class="number">87</span>,<span class="number">63</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">76</span>&#125;</span><br><span class="line">• <span class="comment">#4.获取s1、s2、s3中都包含的元素</span></span><br><span class="line">• sres4 = s1 &amp; s2 &amp; s3</span><br><span class="line">• <span class="built_in">print</span>(sres4)</span><br><span class="line">• <span class="comment">#5.获取s1、s2、s3中，只出现一次的元素</span></span><br><span class="line">• sres5 = (s1 ^ s2 ^ s3)- (s1 &amp; s2 &amp; s3)</span><br><span class="line">• <span class="built_in">print</span>(sres5)</span><br></pre></td></tr></table></figure><h3 id="str数据类型（字符串）选择填空判断"><a href="#str数据类型（字符串）选择填空判断" class="headerlink" title="str数据类型（字符串）选择填空判断"></a>str数据类型（字符串）选择填空判断</h3><p>• Python中没有独立的字符数据类型，字符即长度为1的字符串<br>• Python内置数据类型str，用于字符串处理</p><ul><li>str对象的值为字符系列</li><li>str对象（字符串）是不可变对象</li></ul><p>• 使用单引号或双引号括起来的内容，是字符串的字面量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>对象</span><br><span class="line">• 创建<span class="built_in">str</span>类型的对象实例           <span class="built_in">str</span>(<span class="built_in">object</span>=<span class="string">&#x27;&#x27;</span>--------<span class="comment">#创建str对象，默认为空字符串)</span></span><br><span class="line">                             </span><br><span class="line">【例】使用<span class="built_in">str</span>()创建字符串对象的应用示例：将给定整数的各个位数上的数字累加</span><br><span class="line">intN=<span class="number">123456</span> <span class="comment">#给定一个整数</span></span><br><span class="line">total=<span class="number">0</span> <span class="comment">#累加和total赋初值</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>(intN): <span class="comment">#将整数转换为字符串，利用for语句迭代字符串序列</span></span><br><span class="line">total += <span class="built_in">int</span>(s) <span class="comment">#将字符转换为整数，实现各个位数上的数字累加</span></span><br><span class="line"><span class="built_in">print</span>(total) <span class="comment">#输出给定整数的各个位数上的数字累加和,运行结果为21</span></span><br><span class="line">                             </span><br><span class="line"><span class="built_in">str</span>对象属性和方法</span><br><span class="line">• <span class="built_in">str</span>对象的方法有两种调用方式：字符串对象的方法和<span class="built_in">str</span>类方法</span><br><span class="line">                             </span><br><span class="line">• 【例】<span class="built_in">str</span>对象方法示例</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.upper() <span class="comment">#字符串对象s的方法。输出：&#x27;ABC&#x27;</span></span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>.upper(s) <span class="comment">#str类方法，字符串s作为参数。输出：&#x27;ABC&#x27;</span></span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">                             </span><br><span class="line"> <span class="built_in">str</span>.isalnum() <span class="comment">#是否全为字母或者数字</span></span><br><span class="line"> <span class="built_in">str</span>.isalpha() <span class="comment">#是否全为字母</span></span><br><span class="line"> <span class="built_in">str</span>.islower() <span class="comment">#是否全为小写</span></span><br><span class="line"> <span class="built_in">str</span>.isupper() <span class="comment">#是否全为大写</span></span><br><span class="line"> <span class="built_in">str</span>.isnumeric() <span class="comment">#是否只包含数字字符</span></span><br><span class="line">  <span class="built_in">str</span>.istitle() 函数用于检查字符串中的每个单词的首字母是否都是大写，并且其他字母都是小写</span><br><span class="line">  <span class="built_in">str</span>.isdigit() 函数用于检查字符串是否只包含数字字符（<span class="number">0</span>-<span class="number">9</span>）</span><br><span class="line">                             </span><br><span class="line">例】字符串类型判断示例</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="string">&#x27;yellow ribbon&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="string">&#x27;Pascal Case&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3=<span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s4=<span class="string">&#x27;iPhone7&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.islower()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.isupper()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s4.isalnum()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3.isnumeric()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.isdigit()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2.istitle()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">                             </span><br><span class="line"> <span class="built_in">str</span>.lower() <span class="comment">#转换为小写</span></span><br><span class="line"> <span class="built_in">str</span>.upper() <span class="comment">#转换为大写</span></span><br><span class="line">                             </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="string">&#x27;Pascal Case&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3=<span class="string">&#x27;python3.7‘</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s2.lower()</span></span><br><span class="line"><span class="string">&#x27;</span>pascal <span class="keyword">case</span>‘</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3.upper()</span><br><span class="line"><span class="string">&#x27;PYTHON3.7  </span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string"> str.strip([chars]) #去两边空格，也可指定要去除的字符列表</span></span><br><span class="line"><span class="string"> str.lstrip([chars]) #去左边空格，也可指定要去除的字符列表</span></span><br><span class="line"><span class="string"> str.rstrip([chars]) #去右边空格，也可指定要去除的字符列表</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string"> str.startswith(prefix[, start[, end]]) #是否以prefix开头</span></span><br><span class="line"><span class="string"> str.endswith(suffix[, start[, end]]) #是否以suffix结尾</span></span><br><span class="line"><span class="string"> str.count(sub[, start[, end]]) #返回指定字符串出现的次数</span></span><br><span class="line"><span class="string"> str.index(sub[, start[, end]]) #搜索指定字符串，返回下标，无则导致ValueError</span></span><br><span class="line"><span class="string"> str.split(sep=None, maxsplit=-1) #按指定字符（默认为空格）分割字符串，</span></span><br><span class="line"><span class="string">                                   #返回列表maxsplit为最大分割次数，默认-1，无限制</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1=&#x27;</span><span class="number">123</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s2=&#x27;</span> <span class="number">123</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; len(s2)</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s2.strip()</span></span><br><span class="line"><span class="string">&#x27;</span><span class="number">123</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s2.lstrip()</span></span><br><span class="line"><span class="string">&#x27;</span><span class="number">123</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">                             </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1=&quot;abABabCD&quot;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1.startswith(&quot;AB&quot;)</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1.startswith(&quot;AB&quot;,2)</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1.endswith(&quot;CD&quot;)</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1.count(&quot;ab&quot;)</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s1.index(&quot;AB&quot;)</span></span><br><span class="line"><span class="string">2</span></span><br></pre></td></tr></table></figure><h3 id="Python字符串字面量-选择填空判断"><a href="#Python字符串字面量-选择填空判断" class="headerlink" title="Python字符串字面量-选择填空判断"></a>Python字符串字面量-选择填空判断</h3><ol><li>单引号（’ ‘）。包含在单引号中的字符串，其中可以包含双引号</li><li>双引号（” “）。包含在双引号中的字符串，其中可以包含单引号</li><li>三单引号（”‘ ‘“）。包含在三单引号中的字符串，可以跨行</li><li>三双引号（””” “””）。包含在双引号中的字符串，可以跨行</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;abc&#x27;</span> <span class="comment">#输出：&#x27;abc‘</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;Hello&quot;</span> <span class="comment">#输出：&#x27;Hello‘</span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&quot;python&quot;</span>) <span class="comment">#输出：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Blue&#x27;</span> <span class="string">&#x27;Sky&#x27;</span> <span class="comment">#输出：&#x27;BlueSky‘</span></span><br><span class="line"><span class="string">&#x27;BlueSky&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字符串编码-选择填空判断"><a href="#字符串编码-选择填空判断" class="headerlink" title="字符串编码-选择填空判断"></a>字符串编码-选择填空判断</h3><p>• Python 3字符默认为16位Unicode编码<br>• 使用内置函数ord()可以把字符转换为对应的Unicode码；使用内置函数chr()可以把十进制数转换为对应的字符</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) <span class="comment">#输出：65</span></span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">65</span>) <span class="comment">#输出：&#x27;A‘</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">ord</span>(<span class="string">&#x27;张&#x27;</span>) <span class="comment">#输出：24352</span></span><br><span class="line"><span class="number">24352</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">chr</span>(<span class="number">24352</span>) <span class="comment">#输出：&#x27;张‘</span></span><br><span class="line"><span class="string">&#x27;张&#x27;</span></span><br></pre></td></tr></table></figure><p>• 列表 元组 集合等的特点比较（是否可变 是否有序 是否可以允许有重复的元素）</p><p>   答：列表：可变，有序，可以重复         元组：不可变，有序，可以重复        集合：可变，无序，不能重复</p><p>• 对象的id和修改了相应的元素之后，其内存地址是否发生变化，元组和列表之间元素不可修改指的是不可原地修改，列表的“+”和列表的append之间的区别（append是原地修改）</p><p>   答：对于可变对象（如列表、集合、字典等），修改对象的元素或内容并不会改变对象的内存地址。</p><p>​           如果修改元组中的列表，是可以修改的</p><p>​           <code>+</code> 运算符用于连接（合并）两个列表，生成一个新的列表，其中包含两个列表的所有元素。它不会修改原始列表，而是创建一个新的列表</p><p>​           <code>append()</code> 方法用于在列表的末尾追加一个元素。它会修改原始列表</p><p>• 此处可以出选择填空判断，也可以结合具体的实例出代码相关的题目</p><h2 id="math库和random库"><a href="#math库和random库" class="headerlink" title="math库和random库"></a>math库和random库</h2><p>• math模块包含两个常量math.pi和math.e，分别对应于</p><p>圆周率π（3.141592653589793）和自然常数e（2.718281828459045）</p><p>• random模块包含各种伪随机数生成函数，以及各种根据概率分布生成随机数的函数，</p><p>使用random模块函数seed()可以设置伪随机数生成器的种子</p><p><img src="https://i.imgloc.com/2023/06/15/VOv1iz.png" alt="VOv1iz.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">• &gt;&gt;&gt; <span class="keyword">import</span> random</span><br><span class="line">• &gt;&gt;&gt; random.seed(<span class="number">1</span>) <span class="comment">#设置种子为1</span></span><br><span class="line">• &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">5</span>),end=<span class="string">&#x27;,&#x27;</span>) <span class="comment">#输出：2,5,1,3,1,</span></span><br><span class="line">• &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">5</span>),end=<span class="string">&#x27;,&#x27;</span>) <span class="comment">#输出：4,4,4,4,2,</span></span><br><span class="line">• &gt;&gt;&gt; random.seed(<span class="number">1</span>) <span class="comment">#重新设置种子为1，结果重复</span></span><br><span class="line">• &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">5</span>),end=<span class="string">&#x27;,&#x27;</span>) <span class="comment">#输出：2,5,1,3,1,</span></span><br><span class="line">• &gt;&gt;&gt; random.seed(<span class="number">10</span>) <span class="comment">#重新设置种子为10</span></span><br><span class="line">• &gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="built_in">print</span>(random.randint(<span class="number">1</span>,<span class="number">5</span>),end=<span class="string">&#x27;,&#x27;</span>) <span class="comment">#输出：5,1,4,4,5,</span></span><br><span class="line"></span><br><span class="line">编写程序，生成一个包含<span class="number">20</span>个<span class="number">0</span>到<span class="number">100</span>之间的随机整数的列表并打印列表，</span><br><span class="line">然后对其中偶数下标的元素进行降序排列，奇数下标的元素不变</span><br><span class="line">• <span class="keyword">import</span> random</span><br><span class="line">• x=[random.randint(<span class="number">0</span>，<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">• <span class="built_in">print</span>(x)</span><br><span class="line">• y=x[::<span class="number">2</span>]</span><br><span class="line">• y.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">• x[::<span class="number">2</span>]=y</span><br><span class="line">• <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">• random库实例</span><br><span class="line">首先随机产生一个<span class="number">1</span>~<span class="number">100</span>以内的整数，请用户猜测具体是哪个数，</span><br><span class="line">即：不断从标准输入读取用户的猜测值，并根据猜测值给出提示信息：“太大”、“太小”或“正确!”</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">secret = random.randrange(<span class="number">1</span>, <span class="number">101</span>)</span><br><span class="line">guess = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> guess != secret:</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请猜测一个100之内的数：&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> (guess &lt; secret): <span class="built_in">print</span>(<span class="string">&#x27;太小&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> (guess &gt; secret): <span class="built_in">print</span>(<span class="string">&#x27;太大&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="built_in">print</span>(<span class="string">&#x27;正确！&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="其他可能会涉及到的考点"><a href="#其他可能会涉及到的考点" class="headerlink" title="其他可能会涉及到的考点"></a>其他可能会涉及到的考点</h2><p>• Jieba库 wordcloud库 time库 datetime库</p><p><strong>jieba库</strong>的安装：pip install jieba</p><p>jieba分词的三种模式：精确模式 jieba.lcut(s)、全模式 jieba.lcut(s,  cut_all&#x3D;True)、</p><p>搜索引擎模式 jieba.lcut_for_sear  ch(s)</p><p><strong>wordcloud</strong>是一个用于生成词云图的Python库。词云图是一种可视化方式，将文本中出现频率较高的词语以云状的形式呈现。</p><p><strong>time库</strong>：</p><p>时间获取：</p><ol><li>time(): 返回当前时间的时间戳，以从1970年1月1日午夜（UTC&#x2F;GMT的历元）到当前时间的秒数表示。</li><li>ctime(): 将时间戳转换为可读的字符串格式，表示为”Day Mon Date hh:mm:ss Year”，例如”Tue Jun 16 13:34:17 2023”。</li><li>gmtime(): 获取当前时间的时间元组（struct_time），以UTC（协调世界时）格式表示。</li></ol><p>时间格式化：</p><ol><li>strftime(format, time_tuple): 将时间元组（time_tuple）根据指定的格式（format）进行格式化，并返回格式化后的字符串。常用的格式化代码包括：%Y（四位数的年份），%m（月份），%d（日期），%H（24小时制的小时数），%M（分钟），%S（秒数）等。</li><li>strptime(string, format): 将指定格式（format）的字符串（string）解析为时间元组。</li></ol><p>程序计时：</p><ol><li>sleep(seconds): 在执行程序时暂停（阻塞）指定的秒数（seconds）。</li><li>perf_counter(): 返回一个具有高分辨率的性能计数器，通常用于测量代码的执行时间。它以秒为单位返回一个浮点数，可以在不同的程序计时点之间进行差值计算来获得代码的执行时间。</li></ol><p><strong>datetime库</strong>：使用datetime.now()获得当前日期和时间对象</p><p>使用datetime.utcnow()获得当前日期和时间对应的UTC（世界标准时间）时间对象</p><p>datetime.now() 和 datetime.utcnow() 都 返 回 一 个datetime类型的对象，也可以直接使用datetime()构造一个<br>日期和时间对象，使用方法如下：datetime(year, month, day, hour&#x3D;0, minute&#x3D;0,second&#x3D;0,microsecond&#x3D;0)<br>作用：返回一个datetime类型，表示指定的日期和时间，可以精确到微秒。</p><p>调用datetime()函数直接创建一个datetime对象，表示2030年11月6日22:33，32秒7微秒，执行结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">someday = datetime(<span class="number">2030</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">32</span>,<span class="number">7</span>)</span><br><span class="line">someday</span><br><span class="line">datetime.datetime(<span class="number">2030</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">32</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>• 函数的全局变量和局部变量（global保留字）</p><p>在Python中，可以使用全局变量和局部变量来存储数据。全局变量是在整个程序中可见的变量，而局部变量则只在特定函数或代码块内部可见。</p><p>当你在函数内部定义一个变量时，它默认是局部变量，只能在该函数内部访问。然而，有时你可能希望在函数内部修改全局变量或在函数外部访问全局变量。这时，你可以使用<code>global</code>保留字来指示一个变量是全局的。</p><p>下面是一个示例，演示如何使用全局变量和<code>global</code>关键字：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy codex = <span class="number">10</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">global</span> x  <span class="comment"># 使用 global 关键字声明 x 为全局变量</span></span><br><span class="line">    x = <span class="number">20</span>  <span class="comment"># 修改全局变量 x</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the function:&quot;</span>, x)</span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Outside the function:&quot;</span>, x)</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个全局变量 <code>x</code> 并赋值为 <code>10</code>。然后，我们在 <code>my_function()</code> 函数中使用 <code>global</code> 关键字声明 <code>x</code> 为全局变量，并将其修改为 <code>20</code>。在函数内部打印 <code>x</code> 的值会输出 <code>20</code>，而在函数外部打印 <code>x</code> 的值也会输出 <code>20</code>，因为在函数内部修改了全局变量的值。</p><p>需要注意的是，在函数内部如果没有使用 <code>global</code> 关键字声明一个变量为全局变量，而只是对该变量进行赋值操作，那么它将被视为一个新的局部变量，而不会修改全局变量的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy codex = <span class="number">10</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    x = <span class="number">20</span>  <span class="comment"># 这是一个新的局部变量，不会修改全局变量 x</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Inside the function:&quot;</span>, x)</span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Outside the function:&quot;</span>, x)  <span class="comment"># 输出：Outside the function: 10</span></span><br></pre></td></tr></table></figure><p>在这个示例中，函数内部的 <code>x = 20</code> 是一个新的局部变量，不会影响全局变量 <code>x</code> 的值。因此，在函数外部打印 <code>x</code> 的值仍然是 <code>10</code>。</p><p>总结一下，使用 <code>global</code> 关键字可以在函数内部修改全局变量的值。如果在函数内部没有使用 <code>global</code> 关键字声明一个变量，它将被视为一个新的局部变量。</p><p>• for else的搭配使用</p><p>在Python中，<code>for...else</code>是一种用于循环语句的结构，它允许在循环正常完成后执行一些特定的代码块。以下是使用<code>for...else</code>的基本语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy codefor item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环体</span></span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        <span class="comment"># 条件满足时的处理</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环正常完成后的处理</span></span><br></pre></td></tr></table></figure><p>这里的<code>iterable</code>是一个可迭代对象（例如列表、元组、字符串等），<code>item</code>是<code>iterable</code>中的每个元素。在循环中，你可以执行一些操作，并根据某些条件来检查是否需要中断循环。如果条件满足并使用了<code>break</code>语句中断循环，那么<code>else</code>部分将被跳过。但是，如果循环没有被中断，即循环正常完成，那么将执行<code>else</code>部分的代码。</p><p>下面是一个示例，演示如何使用<code>for...else</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy codefruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="keyword">if</span> fruit == <span class="string">&#x27;orange&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found orange!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Orange not found!&quot;</span>)</span><br></pre></td></tr></table></figure><p>在上述示例中，我们遍历了一个水果列表。如果列表中存在字符串<code>orange</code>，我们将打印”Found orange!”，然后使用<code>break</code>中断循环。否则，如果循环正常完成（即没有找到橙子），我们将打印”Orange not found!”。</p><p>请注意，<code>for...else</code>并不是必须使用的语法，但它提供了一种简洁的方式来在循环正常完成时执行某些代码。</p><p>• 素数 回文数…(第二次作业)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当从键盘输入一个任意位数的数字时，请编写程序判断这个数字是不是回文偶数。</span><br><span class="line">nums = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个回文偶数:&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nums % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这不是一个偶数&quot;</span>)</span><br><span class="line"></span><br><span class="line">nums_str = <span class="built_in">str</span>(nums)</span><br><span class="line">length = <span class="built_in">len</span>(nums_str)  <span class="comment"># 241142 65156</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums_str:</span><br><span class="line">    i = <span class="built_in">int</span>(i)</span><br><span class="line">    var = nums_str[length - i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> var == nums_str[i]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;这不是一个回文偶数&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是一个回文偶数&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python复习总结1</title>
      <link href="/post/bc5cbd8.html"/>
      <url>/post/bc5cbd8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python复习和回顾："><a href="#Python复习和回顾：" class="headerlink" title="Python复习和回顾："></a>Python复习和回顾：</h1><h2 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h2><p>• 选择题-（1.5-20道）30<br>• 填空题-（1.5-8个空）12<br>• 判断题-（1-9道）9<br>• 程序推断（看代码，推断写出代码运行后的结果或者对给出的代码进行修改-5-5道）25<br>• 程序书写（根据题目要求，写出相应的程序）8*3道-24</p><h2 id="考试章节和内容"><a href="#考试章节和内容" class="headerlink" title="考试章节和内容"></a>考试章节和内容</h2><p>• Python的发展历史（python2和python3的主要不同，python没有考虑向下兼容，即python3不能不加修改地去运行一个用python2语法编写的程序）</p><p>• Python的主要优点（语法简洁 跨平台 胶水语言 开源 强制可读 支持中文 支持面向对象和面向过程类的库丰富）</p><p>• Python执行代码的两种方式：文件式和交互式</p><p>• Python的书写规范（变量 标识符 保留字 内置函数 缩进）</p><p>• Python的库（标准库和第三方库）</p><p>• Python的数据类型</p><p>• 循环结构</p><h2 id="1-Python2和python3"><a href="#1-Python2和python3" class="headerlink" title="1.Python2和python3"></a>1.Python2和python3</h2><ul><li>在Python 2中，<code>print</code>是一个语句，括号是可选的。</li><li>在Python 3中，<code>print</code>是一个函数，括号是必需的。</li></ul><h2 id="2-numpy和科学计算（选择-填空）"><a href="#2-numpy和科学计算（选择-填空）" class="headerlink" title="2.numpy和科学计算（选择 填空）"></a>2.numpy和科学计算（选择 填空）</h2><ul><li>numpy是第三方库，需要安装（有别于random time datetime turtle等标准库）</li><li>相应的方法：统计元素个数-**np.size()**，元素包含的字节长度-<strong>np.itemsize()</strong> ，</li></ul><p>创建全为0的矩阵<strong>zeros</strong>，全为1的矩阵<strong>ones</strong>，单位矩阵-<strong>identity</strong>，更改维度-<strong>reshape</strong>，</p><p>可以实现转置的操作（**array.T np.transpose(array)  array.swapaxes(0,1)**），</p><p>可以实现平铺的操作(<strong>array.flatten()</strong> 和**array.ravel()**，它们的区别是前者修改之后不会改变原有矩阵的数据)</p><p><img src="https://i.imgloc.com/2023/06/13/VHv7wk.png" alt="VHv7wk.png"></p><p><img src="https://i.imgloc.com/2023/06/13/VHvgYx.png" alt="VHvgYx.png"></p><p><img src="https://i.imgloc.com/2023/06/15/VOvQbw.png" alt="VOvQbw.png"></p><h2 id="3-文件的读写"><a href="#3-文件的读写" class="headerlink" title="3.文件的读写"></a>3.文件的读写</h2><ul><li><p>文件的分类（二进制文件和文本文件）;</p><p>打开文件的两个参数（mode 文件名），打开文件相关的保留字：（with as），</p><p>打开文件的读取方法包括：**readall();read();readline();readlines()**；假设文件对象为fp，则fp.closed表示文件的打开状态，fp.name表示被打开的文件的名称。</p><p>readlines会得到一个包含换行符的一个所有行的列表，writelines会将一个列表写入文件中。</p><p>Seek后边可以接offset，其中0表示文件开头，1表示当前位置，2表示文件结尾。</p></li><li><p>Python中使用文件对象的tell( )方法返回文件的当前读写位置。</p></li><li><p>假如要读取所有的文本，可以使用read()，而括号中不写数字；</p><p>readline可以读取一行，readlines则读取当前位置到文件末尾的所有行，并将这些行以列表的形式返回。</p></li></ul><p>典型实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例<span class="number">1</span></span><br><span class="line"></span><br><span class="line">fname = <span class="built_in">input</span>(<span class="string">&quot;请输入要写入的文件: &quot;</span>)</span><br><span class="line">fo = <span class="built_in">open</span>(fname, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line">ls = [<span class="string">&quot;唐诗&quot;</span>, <span class="string">&quot;宋词&quot;</span>, <span class="string">&quot;元曲&quot;</span>]</span><br><span class="line">fo.writelines(ls)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">     <span class="built_in">print</span>(line)</span><br><span class="line">fo.close()</span><br><span class="line"></span><br><span class="line">程序执行结果如下：</span><br><span class="line">&gt;&gt;&gt;请输入要写入的文件: e:\liushuo\唐诗宋词.txt</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">实例<span class="number">2</span></span><br><span class="line">fname = <span class="built_in">input</span>(<span class="string">&quot;请输入要写入的文件: &quot;</span>)</span><br><span class="line">fo = <span class="built_in">open</span>(fname, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line">ls = [<span class="string">&quot;唐诗&quot;</span>, <span class="string">&quot;宋词&quot;</span>, <span class="string">&quot;元曲&quot;</span>]</span><br><span class="line">fo.writelines(ls)</span><br><span class="line">fo.seek(<span class="number">0</span>)  <span class="comment">#使用fo.seek(0)将文件指针重新定位到文件的开头</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo:</span><br><span class="line">     <span class="built_in">print</span>(line)</span><br><span class="line">fo.close()</span><br><span class="line"></span><br><span class="line">程序执行结果如下：</span><br><span class="line">&gt;&gt;&gt;请输入要写入的文件: e:\liushuo\唐诗宋词.txt</span><br><span class="line">&gt;&gt;&gt;唐诗宋词元曲</span><br></pre></td></tr></table></figure><p>典型实例2：文件的基本操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">例 请输出文本文件file1.txt中的纯文本，并统计文本文件中大写字母出现的次数。</span><br><span class="line">分析：读取文件的所有行，以列表返回，然后遍历列表，统计大写字母的个数。</span><br><span class="line"></span><br><span class="line"> fp=<span class="built_in">open</span>(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"> ls=fp.readlines() <span class="comment">#读取文件的所有行，以列表返回</span></span><br><span class="line"> c=<span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> x <span class="keyword">in</span> ls: <span class="comment">#遍历列表ls</span></span><br><span class="line">     <span class="built_in">print</span>(x.strip()) <span class="comment">#输出文件的每一个行（不包括’\n’）</span></span><br><span class="line">     <span class="keyword">for</span> s <span class="keyword">in</span> x: <span class="comment">#遍历每个列表元素</span></span><br><span class="line">         <span class="keyword">if</span> s.isupper():</span><br><span class="line">         c=c+<span class="number">1</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;文件中大写字母有&#123;&#125;个。&quot;</span>.<span class="built_in">format</span>(c))</span><br><span class="line"> fp.close()</span><br><span class="line">    </span><br><span class="line">运行程序，结果如下：</span><br><span class="line">Hello!</span><br><span class="line">Life <span class="keyword">is</span> short,you need Python.</span><br><span class="line">文件中大写字母有<span class="number">3</span>个。</span><br><span class="line"></span><br><span class="line">例 输入一段字符串，转换成列表，并统计输入的一段字符串中大写字母出现的次数。</span><br><span class="line"></span><br><span class="line"> str1=<span class="built_in">input</span>(“请输入一段字符串:<span class="string">&quot;)</span></span><br><span class="line"><span class="string"> ls=list(str1) #读取文件的所有行，以列表返回</span></span><br><span class="line"><span class="string"> c=0</span></span><br><span class="line"><span class="string"> for x in ls: #遍历列表ls</span></span><br><span class="line"><span class="string">     if x.isupper():</span></span><br><span class="line"><span class="string">          c=c+1</span></span><br><span class="line"><span class="string"> print(“字符串中大写字母有&#123;&#125;个。&quot;</span>.<span class="built_in">format</span>(c))</span><br></pre></td></tr></table></figure><h2 id="4-递归和循环"><a href="#4-递归和循环" class="headerlink" title="4.递归和循环"></a>4.递归和循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">实例<span class="number">1</span>-求阶乘(假设参数为<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">循环</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>) :   </span><br><span class="line">    s=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">         s *= i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">fact(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">递归</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>)</span><br><span class="line">num = <span class="built_in">eval</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(fact(<span class="built_in">abs</span>(<span class="built_in">int</span>(num))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实例<span class="number">2</span>-循环-最大公约数计算。从键盘输入两个整数，编写程序求这两个整数的最大公约数和最小公倍数。</span><br><span class="line">（求最大公约数使用辗转相除法，求最小公倍数用两数的积除以最大公约数）</span><br><span class="line"></span><br><span class="line">• a=<span class="built_in">int</span>(<span class="built_in">input</span>(“请输入数字：<span class="string">&quot;))</span></span><br><span class="line"><span class="string">• b=int(input(“请输入数字：&quot;</span>))</span><br><span class="line">• <span class="comment"># 先给两数排序，保证大数除以小数</span></span><br><span class="line">• m=<span class="built_in">max</span>(a,b)</span><br><span class="line">• n=<span class="built_in">min</span>(a,b)</span><br><span class="line">• t=m%n</span><br><span class="line">• <span class="keyword">while</span> t!=<span class="number">0</span>:</span><br><span class="line">•        m,n=n,t <span class="comment"># 每个除式的m、n都是上一个式子的n和余数</span></span><br><span class="line">•        t=m%n <span class="comment"># 更新余数</span></span><br><span class="line">• <span class="built_in">print</span>(“&#123;&#125;和&#123;&#125;的最大公约数为&#123;&#125;,最小公倍数为&#123;&#125;<span class="string">&quot;.format(a,b,n,a*b/n))</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">实例2-递归-最大公约数计算。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">def Gongyueshu(a, b):</span></span><br><span class="line"><span class="string">    # 比大小，保证大数除以小数</span></span><br><span class="line"><span class="string">    if a &lt; b:</span></span><br><span class="line"><span class="string">        a, b = b, a</span></span><br><span class="line"><span class="string">    # 判断是否能整除，若能整除，直接返回被除数</span></span><br><span class="line"><span class="string">    if a % b == 0:</span></span><br><span class="line"><span class="string">        return b</span></span><br><span class="line"><span class="string">    # 若不能整除，则返回函数gongyueshu，参数做相应变化</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        return Gongyueshu(b, a % b)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a = int(input(&quot;</span>请输入第一个数字：<span class="string">&quot;))</span></span><br><span class="line"><span class="string">b = int(input(&quot;</span>请输入第二个：<span class="string">&quot;))</span></span><br><span class="line"><span class="string">gcd = Gongyueshu(a, b)</span></span><br><span class="line"><span class="string">print(f&quot;</span>&#123;a&#125;和&#123;b&#125;的最大公约数为&#123;gcd&#125;<span class="string">&quot;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">实例3-循环-斐波那契数列（设天数为10）</span></span><br><span class="line"><span class="string">def fib(n):</span></span><br><span class="line"><span class="string">    a, b = 0, 1</span></span><br><span class="line"><span class="string">    while a &lt; n:</span></span><br><span class="line"><span class="string">          print(a, end=&#x27; &#x27;)</span></span><br><span class="line"><span class="string">          a, b = b, a+b</span></span><br><span class="line"><span class="string">    print()</span></span><br><span class="line"><span class="string">fib(10)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">递归</span></span><br><span class="line"><span class="string">def f(n):</span></span><br><span class="line"><span class="string">    if n == 1 or n == 2 :</span></span><br><span class="line"><span class="string">         return 1</span></span><br><span class="line"><span class="string">    else :</span></span><br><span class="line"><span class="string">         return f(n-1) + f(n-2)</span></span><br><span class="line"><span class="string">print(f(10))</span></span><br></pre></td></tr></table></figure><h2 id="5-Python库的安装（选择填空判断）"><a href="#5-Python库的安装（选择填空判断）" class="headerlink" title="5.Python库的安装（选择填空判断）"></a>5.Python库的安装（选择填空判断）</h2><p>使用pip工具 pip install 库，pip可以实现安装扩展包 可以卸载扩展包 可以更新扩展包。</p><p>例如：<code>pip install numpy</code></p><h2 id="6-turtle标准库"><a href="#6-turtle标准库" class="headerlink" title="6.turtle标准库"></a>6.turtle标准库</h2><ul><li><p>库的几种导入方法（选择填空）<strong>from &lt;库名&gt; import &lt;函数名&gt;</strong> ;**from &lt;库名&gt; import ***;</p><p><strong>import turtle</strong> ; <strong>import numpy as np</strong></p></li><li><p>turtle相应的方法：goto(),<strong>penup(), pendown(),pensize(), pencolor()</strong>, turtle.fd(), turtle.circle(),<br><strong>turtle.setheading(angle)</strong>-<strong>turtle.seth(angle)</strong>(angle: 行进方向的绝对角度),<br>**turtle.left(angle) ** <strong>turtle.right(angle)</strong>(同样是绝对角度)</p></li><li><p><strong>代码相关部分（使用turtle相应的方法来绘制常见的图形，如多边形，熟悉如何常规绘制和用for循环来完成）</strong></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用turtle库中的turtle.fd()函数和turtle.seth()函数绘制一个等边三角形，边长为<span class="number">100</span>：</span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> * </span><br><span class="line">fd(<span class="number">100</span>) <span class="comment">#向前移动100个单位，即绘制第一条边。</span></span><br><span class="line">left(<span class="number">120</span>) </span><br><span class="line">fd(<span class="number">100</span>) </span><br><span class="line">left(<span class="number">120</span>) </span><br><span class="line">fd(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">用<span class="keyword">for</span>循环来完成绘制</span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  t.seth(i* <span class="number">120</span>)</span><br><span class="line">  t.fd(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">如何去绘制正多边形？（使用<span class="keyword">for</span>循环）</span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    t.seth(i * <span class="number">90</span>)</span><br><span class="line">    t.fd(<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">如何去绘制一个长度为<span class="number">200</span>的菱形？（使用<span class="keyword">for</span>循环）</span><br><span class="line"><span class="keyword">import</span> turtle <span class="keyword">as</span> t</span><br><span class="line">t.right(-<span class="number">30</span>)             <span class="comment">#改变出发角度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):   <span class="comment">#在此循环中,i取值为0和1</span></span><br><span class="line">  t.fd(<span class="number">200</span>)</span><br><span class="line">  t.right(<span class="number">60</span>*(i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>): </span><br><span class="line">  t.fd(<span class="number">200</span>)</span><br><span class="line">  t.right(<span class="number">60</span>*(i+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="7-ELSE"><a href="#7-ELSE" class="headerlink" title="7.ELSE"></a>7.ELSE</h2><h3 id="IPO描述（选择填空判断）"><a href="#IPO描述（选择填空判断）" class="headerlink" title="IPO描述（选择填空判断）"></a>IPO描述（选择填空判断）</h3><p>IPO是指 input process output<br>接收华氏温度和摄氏温度并相互转换的IPO描述是什么？<br>Input-输入：带华氏或摄氏标志的温度值<br>Process-处理：根据温度标志选择适当的温度转换算法<br>Output-输出：带有摄氏或华氏标志的温度值</p><h3 id="Python的缩进和注释（选择填空判断）"><a href="#Python的缩进和注释（选择填空判断）" class="headerlink" title="Python的缩进和注释（选择填空判断）"></a>Python的缩进和注释（选择填空判断）</h3><p>严格缩进 ，缩进规则：</p><ul><li>使用空格或制表符（通常为4个空格）来进行缩进。</li><li>同一个代码块中的每一行代码必须使用相同数量的缩进空格或制表符。</li><li>缩进的数量表示代码块的嵌套层次，用于表示控制流语句（如条件语句和循环语句）的执行范围。</li></ul><p>可以通过什么样的方法来引入注释</p><p>单行注释：<code>#</code></p><p>多行注释：<code>&#39;&#39;&#39;</code>或<code>&quot;&quot;&quot;</code></p><h3 id="Python的命名规则（区分大小写-数字不能出现在首字符-中间不能出现空格）"><a href="#Python的命名规则（区分大小写-数字不能出现在首字符-中间不能出现空格）" class="headerlink" title="Python的命名规则（区分大小写 数字不能出现在首字符 中间不能出现空格）"></a>Python的命名规则（区分大小写 数字不能出现在首字符 中间不能出现空格）</h3><p>Python中标识符的一些规则：</p><ul><li>标识符可以包含字母（大小写敏感，A-Z和a-z）、数字（0-9）和下划线（_）。</li><li>标识符的第一个字符必须是字母或下划线，不能以数字开头。</li><li>标识符不能使用Python的关键字（reserved words）作为名称。例如，<code>if</code>、<code>for</code>、<code>while</code>等关键字不能作为标识符。</li><li>标识符可以是任意长度。</li><li>标识符是区分大小写的。例如，<code>myVariable</code>和<code>myvariable</code>是不同的标识符。</li></ul><p>Python的保留字，典型的保留字的名称和用法。</p><ul><li><code>False</code>、<code>True</code>、<code>None</code>：分别表示布尔值<code>False</code>、<code>True</code>和空值。</li><li><code>and</code>、<code>or</code>、<code>not</code>：用于布尔逻辑操作，分别表示逻辑与、逻辑或和逻辑非。</li><li><code>if</code>、<code>else</code>、<code>elif</code>：用于条件语句，控制程序根据条件执行不同的代码块。</li><li><code>while</code>、<code>for</code>、<code>break</code>、<code>continue</code>：用于循环控制，实现代码的重复执行。</li><li><code>def</code>、<code>return</code>、<code>lambda</code>：用于定义函数、返回值和匿名函数的创建。</li><li><code>class</code>、<code>is</code>：用于定义类和判断对象是否相同。</li><li><code>try</code>、<code>except</code>、<code>finally</code>、<code>raise</code>：用于异常处理，捕获和处理程序中的异常。</li><li><code>with</code>、<code>as</code>：用于上下文管理器，提供资源的自动释放。</li><li><code>import</code>、<code>from</code>：用于导入模块和从模块中导入特定的内容。</li><li><code>global</code>、<code>nonlocal</code>：用于访问和修改变量的作用域。</li></ul><h3 id="Input-eval-格式化方法（选择填空判断-代码题目）"><a href="#Input-eval-格式化方法（选择填空判断-代码题目）" class="headerlink" title="Input eval 格式化方法（选择填空判断 代码题目）"></a>Input eval 格式化方法（选择填空判断 代码题目）</h3><p>input获得的是字符串形式，<br>eval可以执行语句，把返回结果输出。<br>format格式化，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">eval</span>(<span class="string">&quot;1&quot;</span>) <span class="comment">#1</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">eval</span>(<span class="string">&quot;1+2&quot;</span>) <span class="comment">#3</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">eval</span>(<span class="string">&#x27;print(&quot;Hello&quot;)&#x27;</span>) <span class="comment">#Hello</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgloc.com/2023/06/13/VHvExL.png" alt="VHvExL.png"></p><p><img src="https://i.imgloc.com/2023/06/13/VH9xNX.png" alt="VH9xNX.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">接收用户输入的一个小于 <span class="number">20</span>的正整数，在屏幕上逐行递增显示从 001 到该正整数，</span><br><span class="line">数字显示的宽度为 <span class="number">3</span>，不足位置补 <span class="number">0</span>，后面追加一个空格，然后显示‘*’号，‘*’号的个数等于行首数字。</span><br><span class="line">x=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个小于20的正整数: &quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:0&gt;3&#125;&quot;</span>.<span class="built_in">format</span>(i),<span class="string">&quot;*&quot;</span>*(i))</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">001 *</span><br><span class="line">002 **</span><br><span class="line">003 ***</span><br><span class="line">004 ****</span><br><span class="line">005 *****</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:=^20&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;python&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:*&gt;20&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;bit&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;0:10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;BIT&quot;</span>))</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======python=======</span><br><span class="line">*****************bit</span><br><span class="line"><span class="string">&#x27;BIT  &#x27;</span></span><br><span class="line"></span><br><span class="line">python输出菱形图案</span><br><span class="line">给定一个菱形的行数，打印出相应的效果，菱形中间行星星的个数是Python控制台输入的数字，且没有空格</span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入菱形宽度：&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, x + <span class="number">1</span>):  <span class="comment"># 外层循环控制上半个三角形共有几行，也就是菱形的宽</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, x - i):  <span class="comment"># 内层循环控制每一行中的空格数目</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># end=&#x27;&#x27;即语句没结束不换行的意思</span></span><br><span class="line">    <span class="built_in">print</span>(i * <span class="string">&#x27;* &#x27;</span>)  <span class="comment"># 根据i的值显示出对应行的星号的数目</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, x):  <span class="comment"># 下半个三角形比上半个三角形少一行，所以i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):  <span class="comment"># 与上半个三角形的语句相似，即空格的数目</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 没结束不换行</span></span><br><span class="line">    <span class="built_in">print</span>((x - i) * <span class="string">&#x27;* &#x27;</span>)</span><br><span class="line"></span><br><span class="line">运行结果：请输入菱形宽度：<span class="number">5</span></span><br><span class="line">     </span><br><span class="line">    * </span><br><span class="line">   * * </span><br><span class="line">  * * * </span><br><span class="line"> * * * * </span><br><span class="line">* * * * * </span><br><span class="line"> * * * * </span><br><span class="line">  * * * </span><br><span class="line">   * * </span><br><span class="line">    * </span><br></pre></td></tr></table></figure><h2 id="8-基本的数据类型"><a href="#8-基本的数据类型" class="headerlink" title="8.基本的数据类型"></a>8.基本的数据类型</h2><p>Python语言中，<strong>一切皆为对象</strong>，而每个对象都属于某个数据类型<br>Python的数据类型包括内置的数据类型、模块中定义的数据类型和用户自定义的类型<br><strong>数值数据类型</strong>：int、bool、float、complex （int float complex这几种数据类型转换的规则）<br><strong>序列数据类型</strong>：不可变（str、tuple）和可变（list）<br><strong>集合数据类型</strong>：set<br><strong>字典数据类型</strong>：dict。例如：{1: “one”, 2: “two”}</p><p>一些函数：pow()求幂次的函数 ，bin()转化为2进制，oct()转化为8进制，hex()转化为16进制，</p><p>int()转化为10进制，type()获取该对象的类型，abs(x)返回绝对值，divmod(x,y)执行整数除法和取模运算，</p><p>pow(x, y[, z])可选的第三个参数 <code>z</code> 表示计算结果的模（取余）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">divmod</span>(<span class="number">10</span>, <span class="number">3</span>))  <span class="comment"># 输出：(3, 1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">3</span>))      <span class="comment"># 输出：8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>))   <span class="comment"># 输出：3（2的3次幂除以5的余数）</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># 输出：&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数值运算操作符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x+y x-y x*y x/y </span><br><span class="line">x//y</span><br><span class="line"><span class="built_in">print</span>(<span class="number">17</span> // <span class="number">5</span>)    <span class="comment"># 输出：3，17除以5的整数商</span></span><br><span class="line"></span><br><span class="line">+x -y</span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(+x)  <span class="comment"># 输出：5，正数标记，结果等于 x</span></span><br><span class="line">y = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(+y)  <span class="comment"># 输出：-10，正数标记，结果等于 y</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(-x)  <span class="comment"># 输出：-5，数值取反，结果为负数</span></span><br><span class="line">y = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(-y)  <span class="comment"># 输出：10，数值取反，结果为正数</span></span><br><span class="line"></span><br><span class="line">x%y x**y x+=y x-=y x*=y x/=y x//=y x%=y x**=y</span><br></pre></td></tr></table></figure><p>数据运算之间的优先级问题（是前结合，还是后结合）-选择填空判断</p><p>如：以下运算的输出结果为：</p><p>bool数据类型和相关运算符-选择填空判断</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">0</span> <span class="comment">#输出：True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> <span class="comment">#输出：1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">or</span> <span class="number">2</span> <span class="comment">#输出：2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span> <span class="comment">#输出：True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> <span class="comment">#输出：2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="comment">#输出：0</span></span><br></pre></td></tr></table></figure><h2 id="9-循环与分支结构"><a href="#9-循环与分支结构" class="headerlink" title="9.循环与分支结构"></a>9.循环与分支结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>]:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;+ - - - - + - - - - +&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;*         *         *&quot;</span>)</span><br><span class="line">       </span><br><span class="line">运行结果：</span><br><span class="line">+ - - - - + - - - - +</span><br><span class="line">*         *         *</span><br><span class="line">*         *         *</span><br><span class="line">*         *         *</span><br><span class="line">*         *         *</span><br><span class="line">+ - - - - + - - - - +</span><br><span class="line">*         *         *</span><br><span class="line">*         *         *</span><br><span class="line">*         *         *</span><br><span class="line">*         *         *</span><br><span class="line">+ - - - - + - - - - +</span><br><span class="line"></span><br><span class="line">编写程序，计算Sn=<span class="number">1</span>-<span class="number">3</span>+<span class="number">5</span>-<span class="number">7</span>+<span class="number">9</span>-<span class="number">11</span>+… （计算从 <span class="number">1</span> 到 n 的所有奇数和偶数的差值之和）</span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入整数n：&quot;</span>))</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">       s-=(<span class="number">2</span>*i-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       s+=(<span class="number">2</span>*i-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><h3 id="程序流程图-选择填空判断"><a href="#程序流程图-选择填空判断" class="headerlink" title="程序流程图-选择填空判断"></a>程序流程图-选择填空判断</h3><p><img src="https://i.imgloc.com/2023/06/13/VH9Mak.png" alt="VH9Mak.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">单分支结构示例：输入两个数a和b，比较两者大小，使得a大于b</span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第1个整数：&quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第2个整数：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入值：&#123;0&#125;, &#123;1&#125;“.format(a, b))</span></span><br><span class="line"><span class="string">if (a &lt; b): #a和b交换</span></span><br><span class="line"><span class="string">   t = a</span></span><br><span class="line"><span class="string">   a = b</span></span><br><span class="line"><span class="string">   b = t</span></span><br><span class="line"><span class="string">print(&quot;</span>降序值：&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;“.<span class="built_in">format</span>(a, b))</span><br><span class="line">      </span><br><span class="line">双单分支结构示例：输入一个数a，如果a大于<span class="number">0</span>，则在屏幕上显示“正数”，否则在屏幕上显示“不是正数”</span><br><span class="line">a=<span class="built_in">input</span>(<span class="string">&quot;请输入一个数：&quot;</span>)</span><br><span class="line">a=<span class="built_in">int</span>(a)</span><br><span class="line"><span class="keyword">if</span> a&gt;<span class="number">0</span>:</span><br><span class="line">   <span class="built_in">print</span>(a,<span class="string">&quot;is positive. &quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(a,<span class="string">&quot;is not positive. &quot;</span>)</span><br><span class="line">      </span><br><span class="line">多分支结构</span><br><span class="line">mark = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入分数：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> (mark &gt;= <span class="number">90</span>): grade = <span class="string">&quot;优&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (mark &gt;= <span class="number">80</span>): grade = <span class="string">&quot;良&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (mark &gt;= <span class="number">70</span>): grade = <span class="string">&quot;中&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (mark &gt;= <span class="number">60</span>): grade = <span class="string">&quot;及格&quot;</span></span><br><span class="line"><span class="keyword">else</span>: grade = <span class="string">&quot;不及格&quot;</span></span><br></pre></td></tr></table></figure><h3 id="for-循环-while循环-break-continue（选择填空判断代码）"><a href="#for-循环-while循环-break-continue（选择填空判断代码）" class="headerlink" title="for 循环 while循环 break continue（选择填空判断代码）"></a>for 循环 while循环 break continue（选择填空判断代码）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用<span class="keyword">continue</span>语句跳过循环。要求输入若干学生成绩（按Q或q结束），如果成绩&lt;<span class="number">0</span>，则重新输入。</span><br><span class="line">统计学生人数和平均成绩</span><br><span class="line">num = <span class="number">0</span>; scores = <span class="number">0</span>; <span class="comment">#初始化学生人数和成绩和</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  s = <span class="built_in">input</span>(<span class="string">&#x27;请输入学生成绩（按Q或q结束）：&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> s.upper() == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">float</span>(s) &lt; <span class="number">0</span>: <span class="comment">#成绩必须&gt;=0  float()用于将传入的参数转换为浮点数类型</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">  num += <span class="number">1</span> <span class="comment">#统计学生人数</span></span><br><span class="line">  scores += <span class="built_in">float</span>(s) <span class="comment">#计算成绩之和</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">计算 <span class="number">1</span>到<span class="number">100</span>的整数和</span><br><span class="line">result = <span class="number">0</span>   <span class="comment">#保存累加结果的变量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    result =result+i  <span class="comment">#上述语句逐个获取从1到100这些值，并做累加操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1到100的整数和为:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">运行程序，结果如下：</span><br><span class="line"><span class="number">1</span>到<span class="number">100</span>的整数和为: <span class="number">5050</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span> <span class="comment">#设置循环变量i初值</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span>  <span class="comment">#设置整数和sum初值</span></span><br><span class="line"><span class="comment"># 设置循环的初始化条件</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span> : <span class="comment"># 当i小于100时，执行循环体</span></span><br><span class="line">    <span class="built_in">print</span>( i)</span><br><span class="line">    <span class="built_in">sum</span>=<span class="built_in">sum</span>+i</span><br><span class="line">    i += <span class="number">1</span> <span class="comment">#改变循环变量i的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1~100 的所有整数和：&quot;</span>,<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">运行程序，结果如下：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">……</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1</span>~<span class="number">100</span> 的所有整数和： <span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="请重点注意range对象相关的点"><a href="#请重点注意range对象相关的点" class="headerlink" title="请重点注意range对象相关的点"></a>请重点注意range对象相关的点</h3><p>在 Python 中，<code>range()</code> 是一个内置函数，用于生成一个整数序列。</p><p><code>range()</code> 函数的基本语法是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(start, stop, step)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>start</code>（可选）：表示序列的起始值，默认为 0。</li><li><code>stop</code>：表示序列的结束值（不包含在序列中）。</li><li><code>step</code>（可选）：表示序列中相邻两个值之间的步长，默认为 1。</li></ul><h3 id="使用try…except…else…finally语句捕获处理异常-一般为选择填空判断，也有少量的可能出代码题目"><a href="#使用try…except…else…finally语句捕获处理异常-一般为选择填空判断，也有少量的可能出代码题目" class="headerlink" title="使用try…except…else…finally语句捕获处理异常-一般为选择填空判断，也有少量的可能出代码题目"></a>使用try…except…else…finally语句捕获处理异常-一般为选择填空判断，也有少量的可能出代码题目</h3><p>说明：</p><ul><li><code>try</code> 代码块中放置可能会引发异常的代码。</li><li><code>except</code> 代码块用于处理特定类型的异常。可以有多个 <code>except</code> 块来捕获不同类型的异常，每个 <code>except</code> 块可以处理特定类型的异常。</li><li><code>else</code> 代码块在没有发生任何异常时执行。如果发生异常，则不会执行该代码块。</li><li><code>finally</code> 代码块无论是否发生异常，都会执行。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会引发异常的代码块</span></span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))</span><br><span class="line">    result = <span class="number">10</span> / x</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="comment"># 处理 ValueError 异常，即输入的不是整数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请输入一个有效的整数&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="comment"># 处理 ZeroDivisionError 异常，即除以 0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除数不能为 0&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 当没有异常发生时执行的代码块</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;计算结果:&quot;</span>, result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否发生异常，都会执行的代码块</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序执行完毕&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信息安全复习笔记_简陋版</title>
      <link href="/post/c306365a.html"/>
      <url>/post/c306365a.html</url>
      
        <content type="html"><![CDATA[<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>1.密码学存在的两大对立分支是（D ）</p><p>A 对称加密和非对称加密</p><p>B 序列算法和分组算法</p><p>C DES 和RSA</p><p>D 密码编码学和密码分析学</p><p>2.关于非对称加密体制的描述正确的是（C ）</p><p>A 加密和解密使用的密钥是一样的</p><p>B 甲若要发送一个文件给乙，只想乙 看到，需要用甲的私钥加密信息再传送，从而保证机密性</p><p>C任何人若想发送加密信息给乙，只需要用乙的公钥将信息加密传送即可</p><p>D 可以从公钥推导出私钥</p><p>3.数字签名过程中，要确保来源于发送者的信息，则用（ ）的（）钥对（   ）进行签名？ C</p><p>A 发送者 公   发送内容的信息摘要</p><p>B 发送者 公   发送的内容</p><p>C 发送者 私  发送内容的信息摘要</p><p>D 发送者 私  发送的内容</p><p>E 接收者 公   发送内容的信息摘要</p><p>F 接收者 公   发送的内容</p><p>4.数字签名过程中，要确保传送消息的保密性（只能有接收方看到），则用（ ）的（ ）钥 对发送消息内容和数字签名进行加密传送  C</p><p>给接收者？</p><p>A 发送者 公       B 发送者 私          C 接收者 公           D 接收者 私</p><p>5.哪种情况证书的序列号应该出现在CRL上（ D ）</p><p>A 有效期内正常的证书</p><p>B 过期的证书</p><p>C 尚未生效的证书</p><p>D 因私钥泄露，且在有效期内的CA证书</p><p>6.PKI中哪个部分负责审核提交用户信息的真实性（C ）</p><p>A CA             B CDA            C RA        D CPS</p><p>7.下面说法正确的是（ C ）</p><p>A 用户要将自己的私钥、公钥都交给CA，CA才能签证书</p><p>B 证书的验证就是看证书能否用CA的公钥打开</p><p>C CRL需要签发者进行签名</p><p>D 证书的更新就是公钥有效期延长</p><p>8.以下关于计算机病毒与蠕虫的特点比较中，说法正确的是(  C)<br> A、在传染机制中，蠕虫是通过宿主程序运行<br> B、在触发机制中，蠕虫的触发者是计算机的使用者<br> C、为系统打补丁，能有效预防蠕虫，但不能有效预防病毒<br> D、蠕虫和病毒都是寄生模式存在</p><p>9.特洛伊木马程序分为客户端（也称为控制端）和服务器端（也称为被控制端）两部分，当用户访问了带有木马的网页后，木马的（B）部分就下载到用户所在的计算机上，并自动运行</p><p>A．客户端<br>B．服务器端<br>C．客户端和服务器端<br>D．客户端或服务器端</p><p>10.（多选）下列各项中，属于计算机病毒主要特征的有(ABCD)</p><p>A.隐蔽性           B 破坏性           C 潜伏性          D 感染性</p><p>11.（B ）对主体和资源的属性进行划分（安全标签），通过预先制定的安全策略对安全标签进行判断，决定主体是否能进行访问。</p><p>A 自主访问控制          B 强制访问控制              C 基于角色的访问控制</p><p>12.防火墙对数据包进行状态检测包过滤时，不可以进行的过滤是（D）</p><p>A 源IP，目标IP         B 源端口，目标端口         C IP协议号         D 数据包的内容</p><p>13.下列说法错误的是(C)</p><p>A包过滤防火墙是最传统、最基本的过滤技术</p><p>B应用级网关的安全性高，并有较好的访问控制</p><p>C DMZ区不受防火墙保护</p><p>D 内网用户通过防火墙访问公共网络的IP，需要对源IP进行NAT转换</p><p>14.入侵检测系统不支持的功能（C ）</p><p>A统计分析异常行为    B 检测分析用户和系统的活动   C网络地址转换  D识别已知攻击</p><p>15.关于入侵检测系统IDS说法正确的是( C )</p><p>A入侵检测系统不能检测内部入侵</p><p>B IDS和防火墙一样必须作为内外部网络的唯一通道</p><p>C 基于误用检测的IDS主要利用模式匹配的方法</p><p>D IDS的数据来自于网络</p><p>16.下面哪种访问控制策略需要安全标签（D）</p><p>A基于角色的访问控制          B 自主访问控制               C基于表示的访问控制              D 强制访问控制</p><p>17.我不允许别人ping我，我的防火墙设置应该是出站还是入站？是允许连接还是阻止连接？</p><p>答：如果您不希望其他人ping您，您应该在防火墙的<strong>入站规则</strong>中设置<strong>阻止连接</strong>。入站规则是用来限制远程主机访问本机的服务的，本机接收的请求中如果被请求的程序或具体端口是被限制的，则该请求会被拦截</p><p>18.若我办公室的机器默认不能使用某个联网的程序A，现在通过防火墙设置允许使用，应该在出站还是入站规则中设置？</p><p>答：若您希望在办公室的计算机上使用某个联网程序A，您应该在防火墙的<strong>出站规则</strong>中设置<strong>允许连接</strong>。出站规则是用来限制对外访问的，从本机发出的请求中，如果请求的对象是被禁止的，该请求会被拦截，表现方式就是断网</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>1.信息安全的特征：</p><ul><li>保密性</li><li>完整性</li><li>可用性</li><li>可控性</li><li>不可抵赖性</li></ul><p>2.ISO安全体系结构包括了三部分内容：</p><ul><li>安全服务：认证，访问控制，数据保密性，数据完整性，不可抵赖性（五大类安全服务）</li><li>安全机制：加密机制，数字签名机制，访问控制机制，数据完整性机制，鉴别交换机制，业务填充机制，路由控制机制和公证机制（八大类安全机制）</li><li>安全管理：系统安全管理，安全服务管理，安全机制管理</li></ul><p>3.网络安全体系模型</p><ol><li>PDRR模型：保护Protection，检测Detection，恢复Recovery，响应Response</li><li>P^2DR模型：基于时间的安全模型，Policy安全策略，Protection防护，Detection检测，Recovery响应</li></ol><p>​                                用以下典型的数学公式表达安全的要求</p><p>​                                Pt:防护时间    Dt：检测时间     Rt：响应时间      Et：暴露时间(Et越小越安全)</p><p>​                                Pt &gt; Dt + Rt               Et &#x3D; Dt + Rt</p><p>​                                及时地检测和响应就是安全，及时地检测和恢复就是安全</p><p>4.网络信息安全等级与标准</p><ol><li>TCSEC标准：将计算机安全从高到低分为A,B,C,D四类七个级别（A最高）</li><li>联合公共准则CC标准</li><li>我国有关网络信息安全的相关标准：（五个等级）自主保护级，系统审计保护级，安全标记保护级，结构化保护级和访问验证保护级</li></ol><h2 id="记忆知识点："><a href="#记忆知识点：" class="headerlink" title="记忆知识点："></a>记忆知识点：</h2><p>信息安全特征：1~5</p><p>ISO安全体系结构：1~3</p><p>安全服务：1~5</p><p>安全机制：1~8</p><p>安全管理：1~3</p><p>PDRR：1~4</p><p>PPDR：1~4</p><p>我国将信息安全划分为5个标准：1~5</p><p>密钥的层次结构：1~3</p><p>集中式密钥分配方案：1~5</p><p>分布式密钥分配方案：1~3</p><p>hash函数的特性：1~3</p><p>数字签名的步骤：</p><p>数字签名的分类：1~2</p><p>认证信息类型：1~4</p><p>认证的用途：1~3</p><p>认证方法的分类：1~3</p><p>列举三种常见认证方式（优缺点）：</p><p>Kerberos的设计目标：1~4</p><p>Kerberos的4个基本实体：1~4</p><p>PKI提供4种安全服务：1~4</p><p>PKI组成：1~4</p><p>数字证书内容：1~3（详细）</p><p>数字证书认证过程：1~4</p><p>ARP欺骗原理：1~2</p><p>ARP欺骗得以实现的原因：1~3</p><p>主动口令攻击：1~3</p><p>被动口令攻击：1~3</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Capture the Ether_Lotteries</title>
      <link href="/post/d8e416ee.html"/>
      <url>/post/d8e416ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lotteries"><a href="#Lotteries" class="headerlink" title="Lotteries"></a>Lotteries</h1><p>Feeling lucky? These challenges will show how hard it is to run a fair lottery.</p><hr><p>参考：<a href="https://www.anquanke.com/post/id/154104">https://www.anquanke.com/post/id/154104</a></p><h2 id="Guess-the-number"><a href="#Guess-the-number" class="headerlink" title="Guess the number"></a>Guess the number</h2><h3 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1.题目要求"></a>1.题目要求</h3><p>I’m thinking of a number. All you have to do is guess it.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNumberChallenge &#123;</span><br><span class="line">    uint8 answer = 42;</span><br><span class="line"></span><br><span class="line">    function GuessTheNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><p>这是最简单的，直接把answer给出来了，那么我们直接调用guess函数并传参42即可，同时注意需要发送1 ether，这样就可以把创建合约时存进去的1 ether提取出来</p><p><img src="https://p2.ssl.qhimg.com/t01a17e3bdfbec8c6ea.jpg" alt="img"></p><h2 id="Guess-the-secret-number"><a href="#Guess-the-secret-number" class="headerlink" title="Guess the secret number"></a>Guess the secret number</h2><h3 id="1-题目要求-1"><a href="#1-题目要求-1" class="headerlink" title="1.题目要求"></a>1.题目要求</h3><p>Putting the answer in the code makes things a little too easy.</p><p>This time I’ve only stored the hash of the number. Good luck reversing a cryptographic hash!</p><p>将答案放在代码中会使事情变得过于简单。</p><p>这次我只存储了数字的哈希值。祝你好运逆转加密散列！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line"></span><br><span class="line">    function GuessTheSecretNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (keccak256(n) == answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h3><p>这道题算是上题的进阶版，不过它给出的是一串hash值，我们要完成挑战需要把破解后的数字发送过去，看上去这有点难为人，不过我们发现它给出的参数n的数据类型为uint8，这代表着其长度只有八位，也就是0到255，这样就很简单了，下面是一个简单的爆破合约:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract crack &#123;</span><br><span class="line">    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;</span><br><span class="line">    uint8 public result;</span><br><span class="line"></span><br><span class="line">// keccak256() 函数接受一个或多个参数，并将这些参数作为输入进行哈希计算。</span><br><span class="line">// 它返回一个长度为 256 位的哈希值，通常表示为一个 64 个字符的十六进制字符串。</span><br><span class="line">    function crackresult() returns (uint8) &#123;</span><br><span class="line">        for (uint8 i = 0; i &lt;= 255; i++) &#123;</span><br><span class="line">            if (keccak256(i) == answerHash) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署一下爆破结果:</p><p><img src="https://p3.ssl.qhimg.com/t0126150e126917954c.jpg" alt="img"></p><p>然后提交即可，最后在页面check过关</p><h2 id="Guess-the-random-number"><a href="#Guess-the-random-number" class="headerlink" title="Guess the random number"></a>Guess the random number</h2><h3 id="1-题目要求-2"><a href="#1-题目要求-2" class="headerlink" title="1.题目要求"></a>1.题目要求</h3><p>This time the number is generated based on a couple fairly random sources.</p><p>这次这个数字是根据几个相当随机的来源生成的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function GuessTheRandomNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        // block.blockhash(block.number - 1)</span><br><span class="line">        // 获取前一个区块的哈希值</span><br><span class="line">        answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h3><p>这一关又进阶了，answer还是一串hash，但是是在构造函数里进行了初始化，使用了块的hash和时间戳，事实上这些量在目标合约部署以后都是已知的，我们可以直接在创建块的交易信息里查看，不过简单点我们这里直接在storage里读取即可，此处answer的存储位是在slot 0处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web3.eth.getStorageAt(&quot;0xe3a&quot;,0,console.log)</span><br><span class="line"></span><br><span class="line">使用Web3.js库中的web3.eth.getStorageAt()方法来获取</span><br><span class="line">以太坊区块链上合约地址为&quot;0xe3a&quot;的存储器（storage）中的值</span><br><span class="line"></span><br><span class="line">0：这是存储器的索引或位置。以太坊合约使用存储器来存储持久性数据，存储器可以被看作是合约内部的一个大型字节数组。</span><br><span class="line">在这里，0表示要获取存储器中的第一个位置的值</span><br><span class="line"></span><br><span class="line">console.log：这是一个回调函数，用于处理获取到的存储器值。</span><br><span class="line">当web3.eth.getStorageAt()方法成功返回存储器值时，它将调用该回调函数，并将结果作为参数传递给它。</span><br><span class="line">在这里，console.log是一个用于将结果输出到控制台的回调函数。</span><br><span class="line"></span><br><span class="line">综上所述，该代码的作用是通过Web3.js库中的web3.eth.getStorageAt()方法从指定合约地址的存储器中获取特定位置</span><br><span class="line">的值，并将结果输出到控制台。</span><br></pre></td></tr></table></figure><p>因为使用了metamask插件，所以我们的浏览器已经加载了web3.js，所以我们可以直接在控制台里与Ropsten测试链交互:<br><img src="https://p3.ssl.qhimg.com/t01b3e621cf0bdd46d9.jpg" alt="img"></p><p>可见answer即为0x2f，也就是47.然后按流程提交即可，注意发送交易时需要1 ether</p><p><img src="https://p4.ssl.qhimg.com/t0183a51ddc95b5cbc5.jpg" alt="img"></p><h2 id="Guess-the-new-number"><a href="#Guess-the-new-number" class="headerlink" title="Guess the new number"></a>Guess the new number</h2><h3 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h3><p>The number is now generated on-demand when a guess is made.</p><p>现在，当进行猜测时，该数字会按需生成。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解-3"><a href="#2-题解-3" class="headerlink" title="2.题解"></a>2.题解</h3><p>核心思想就是要在guess函数执行前知道前一个区块的hash与当前块的时间戳，我们知道每个区块里会包含许多交易，对于这些交易前一区块的hash与时间戳都是相同的，所以我们只要部署另一个合约来调用目标合约的guess函数以使这两个交易在一个块内，攻击合约很简单，如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function GuessTheNewNumberChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess(uint8 n) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">        if (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract attacker &#123;</span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        uint8 result = uint8(keccak256(block.blockhash(block.number - 1), now));</span><br><span class="line"></span><br><span class="line">      // 创建了一个名为target的合约实例，</span><br><span class="line">      // 并将指定的地址0xE8BE7654f6C8C23026939901b80530dCf0AfCA75传递给构造函数。</span><br><span class="line">      // 然后，使用target实例调用了名为guess的函数，同时向其发送了1以太币的价值，</span><br><span class="line">      // 并将之前计算得到的result作为参数传递给该函数</span><br><span class="line">        GuessTheNewNumberChallenge target = GuessTheNewNumberChallenge(0xE8BE7654f6C8C23026939901b80530dCf0AfCA75);</span><br><span class="line">        target.guess.value(1 ether)(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好是有个fallback函数以便我们调用attack函数时发送1 ether，接下来就很简单，部署攻击合约以后调用attack函数并发送1 ether</p><p><img src="https://p4.ssl.qhimg.com/t01c6c85e4e4b249cf0.jpg" alt="img"></p><p>挑战完成，check进入下一关</p><h2 id="Predict-the-future"><a href="#Predict-the-future" class="headerlink" title="Predict the future"></a>Predict the future</h2><h3 id="1-题目-1"><a href="#1-题目-1" class="headerlink" title="1.题目"></a>1.题目</h3><p>This time, you have to lock in your guess before the random number is generated. To give you a sporting chance, there are only ten possible answers.</p><p>Note that it is indeed possible to solve this challenge without losing any ether.</p><p>这一次，您必须在生成随机数之前锁定您的猜测。为了给你一个运动的机会，只有十个可能的答案。</p><p>请注意，确实有可能在不损失任何以太币的情况下解决这一挑战。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheFutureChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(uint8 n) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解-4"><a href="#2-题解-4" class="headerlink" title="2.题解"></a>2.题解</h3><h2 id="Predict-the-block-hash"><a href="#Predict-the-block-hash" class="headerlink" title="Predict the block hash"></a>Predict the block hash</h2><h3 id="1-题目-2"><a href="#1-题目-2" class="headerlink" title="1.题目"></a>1.题目</h3><p>Guessing an 8-bit number is apparently too easy. This time, you need to predict the entire 256-bit block hash for a future block.</p><p>猜测一个 8 位数字显然太容易了。这一次，您需要预测未来区块的整个 256 位区块哈希。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function PredictTheBlockHashChallenge() public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return address(this).balance == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function lockInGuess(bytes32 hash) public payable &#123;</span><br><span class="line">        require(guesser == 0);</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function settle() public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser = 0;</span><br><span class="line">        if (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解-5"><a href="#2-题解-5" class="headerlink" title="2.题解"></a>2.题解</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Capture the Ether</title>
      <link href="/post/40996644.html"/>
      <url>/post/40996644.html</url>
      
        <content type="html"><![CDATA[<h1 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h1><p>The warmup challenges are intended to get you familiar with the way Capture the Ether works and the tools you need to use.</p><p>Warmup挑战旨在让您熟悉 Capture the Ether 的工作方式以及您需要使用的工具。</p><hr><p>说明：该靶场需要Ropsten测试网络，该网络已经被弃用，无法完成合约的交互，只能写每道题的题解</p><h2 id="Deploy-a-contract"><a href="#Deploy-a-contract" class="headerlink" title="Deploy a contract"></a>Deploy a contract</h2><h3 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1.题目要求"></a>1.题目要求</h3><p>To complete this challenge, you need to:</p><ol><li>Install <a href="https://metamask.io/">MetaMask</a>.</li><li>Switch to the <strong>Ropsten test network</strong>.</li><li>Get some Ropsten ether. Clicking the “buy” button in MetaMask will take you to a <em>faucet</em> that gives out free test ether.</li></ol><p>After you’ve done that, press the red button on the left to deploy the challenge contract.↳</p><p>You don’t need to do anything with the contract once it’s deployed. Just click the “Check Solution” button to verify that you deployed successfully.</p><p>要完成此挑战，您需要：</p><ol><li>安装<a href="https://metamask.io/">MetaMask</a>。</li><li>切换到<strong>Ropsten 测试网络</strong>。</li><li>获取一些 Ropsten ether。单击 MetaMask 中的“购买”按钮将带你到一个提供免费测试以太币的<em>水龙头。</em></li></ol><p>完成后，按左侧的红色按钮部署挑战合约。</p><p>部署后，您无需对合同执行任何操作。只需单击“检查解决方案”按钮即可验证您是否已成功部署。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract DeployChallenge &#123;</span><br><span class="line">    // This tells the CaptureTheFlag contract that the challenge is complete.</span><br><span class="line">    function isComplete() public pure returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><p>第一步是了解怎么操作部署合约，关卡里也写得很清楚了，首先按照metamask，可以直接在chrome的扩展商店搜索安装，然后切换到Ropsten测试链，当然首先是创建钱包设置密码，然后点击Buy按钮去水龙头取一些ether回来</p><p>接下来点击页面右边的红色的deploy即可然后在弹出的交易确认里点击submit即可成功将页面所示的合约部署到测试链上，接下来再点击check并确认交易即可</p><h2 id="Call-me"><a href="#Call-me" class="headerlink" title="Call me"></a>Call me</h2><h3 id="1-题目要求-1"><a href="#1-题目要求-1" class="headerlink" title="1.题目要求"></a>1.题目要求</h3><p>To complete this challenge, all you need to do is call a function.</p><p>The “Begin Challenge” button will deploy the following contract:</p><p>要完成这个挑战，您需要做的就是调用一个函数。</p><p>“Begin Challenge”按钮将部署以下合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">contract CallMeChallenge &#123;</span><br><span class="line">    bool public isComplete = false;</span><br><span class="line"></span><br><span class="line">    function callme() public &#123;</span><br><span class="line">        isComplete = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call the function named <code>callme</code> and then click the “Check Solution” button.</p><p>调用命名的函数<code>callme</code>，然后单击“Check Solution”按钮。</p><h3 id="2-题解-1"><a href="#2-题解-1" class="headerlink" title="2.题解"></a>2.题解</h3><p>这个挑战的目的是让你调用一下部署的合约里的callme函数，方法其实很多，比较简单的我们可以直接在remix里进行调用，将合约代码复制过去后，先编译一下，然后在Run里面将环境切换为injected web3，然后在下面的deploy处将我们挑战的页面里给出的合约地址填上，点击at address即可<br>接下来在下方即可直接调用callme函数</p><p><img src="https://p1.ssl.qhimg.com/t01de757c96b937614e.jpg" alt="img"></p><p>调用之后点击isComplete就会发现已经变为true，然后即可返回挑战进行check</p><h2 id="Choose-a-nickname"><a href="#Choose-a-nickname" class="headerlink" title="Choose a nickname"></a>Choose a nickname</h2><h3 id="1-题目要求-2"><a href="#1-题目要求-2" class="headerlink" title="1.题目要求"></a>1.题目要求</h3><p>It’s time to set your Capture the Ether nickname! This nickname is how you’ll show up on the <a href="https://capturetheether.com/leaderboard/">leaderboard</a>.</p><p>The <code>CaptureTheEther</code> smart contract keeps track of a nickname for every player. To complete this challenge, set your nickname to a non-empty string. The smart contract is running on the Ropsten test network at the address <code>0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4fee</code>.</p><p>是时候设置您的 Capture the Ether 昵称了！<a href="https://capturetheether.com/leaderboard/">这个昵称是您在排行榜</a>上的显示方式。</p><p>智能合约<code>CaptureTheEther</code>会记录每个玩家的昵称。要完成此挑战，请将您的昵称设置为非空字符串。智能合约在地址 的 Ropsten 测试网络上运行<code>0x71c46Ed333C35e4E6c62D32dc7C8F00D125b4fee</code>。</p><p>Here’s the code for this challenge:</p><p>这是这个挑战的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.21;</span><br><span class="line"></span><br><span class="line">// Relevant part of the CaptureTheEther contract.</span><br><span class="line">contract CaptureTheEther &#123;</span><br><span class="line">    mapping (address =&gt; bytes32) public nicknameOf;</span><br><span class="line"></span><br><span class="line">    function setNickname(bytes32 nickname) public &#123;</span><br><span class="line">        nicknameOf[msg.sender] = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Challenge contract. You don&#x27;t need to do anything with this; it just verifies</span><br><span class="line">// that you set a nickname for yourself.</span><br><span class="line">contract NicknameChallenge &#123;</span><br><span class="line">    CaptureTheEther cte = CaptureTheEther(msg.sender);</span><br><span class="line">    address player;</span><br><span class="line"></span><br><span class="line">    // Your address gets passed in as a constructor parameter.</span><br><span class="line">    function NicknameChallenge(address _player) public &#123;</span><br><span class="line">        player = _player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check that the first character is not null.</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        return cte.nicknameOf(player)[0] != 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-题解-2"><a href="#2-题解-2" class="headerlink" title="2.题解"></a>2.题解</h3><p>这一关是让我们设置自己的昵称，也就是在排行榜上显示的名字，其实也是调用个函数的事，操作跟上面一样，合约选择CaptureTheEther，地址填上，调用setNickname函数即可，注意参数填上自己昵称的16进制格式，然后用nicknameOf函数就能看到结果了</p><p><img src="https://p5.ssl.qhimg.com/t013408b9e56d576dba.jpg" alt="img"></p><p>接下来返回挑战点击begin game按钮就会部署一个合约来检查你是否设置了昵称，check以后就能正式开始我们的闯关之旅了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>testHighlight</title>
      <link href="/post/f0ca14a1.html"/>
      <url>/post/f0ca14a1.html</url>
      
        <content type="html"><![CDATA[<p>java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DataStructure.ArrayStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">IStack</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> maxsize=<span class="number">10</span>;</span><br><span class="line">    E[]elem=<span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        elem=(E[])<span class="keyword">new</span> <span class="title class_">Object</span>[maxsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size==maxsize) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;溢出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elem[size++]=obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        E pop=elem[--size];</span><br><span class="line">        <span class="keyword">return</span> pop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        E peek=elem[size-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayStack&lt;String&gt;stack=<span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            stack.push(<span class="string">&quot;item&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stack.push(<span class="string">&quot;溢出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;peek的结果为：&quot;</span>+stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String item=stack.pop();</span><br><span class="line"></span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strs = <span class="built_in">input</span>(<span class="string">&quot;请输入一行字符:&quot;</span>)</span><br><span class="line"></span><br><span class="line">nums, cn, en, other, backspace = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strs:</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="string">u&#x27;\u4e00&#x27;</span> <span class="keyword">and</span> i &lt;= <span class="string">u&#x27;\u9fa5&#x27;</span>:</span><br><span class="line">        cn += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i.isalpha():</span><br><span class="line">        en += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="string">&quot; &quot;</span>:</span><br><span class="line">        backspace += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> i.isdigit():  <span class="comment"># isdigit()函数判断是否是数字</span></span><br><span class="line">        nums += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        other += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您输入的字符串中有&#123;&#125;个空格,有&#123;&#125;个数字,有&#123;&#125;个汉字,有&#123;&#125;个英文字符,&quot;</span></span><br><span class="line">      <span class="string">&quot;有&#123;&#125;个其他字符&quot;</span>.<span class="built_in">format</span>(backspace, nums, cn, en, other))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>javaScript:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">UTXO</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">txId, outputIndex, address, amount</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">txId</span> = txId;                 <span class="comment">// 交易ID</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">outputIndex</span> = outputIndex;   <span class="comment">// 输出索引</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">address</span> = address;           <span class="comment">// 地址</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">amount</span> = amount;             <span class="comment">// 金额</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取交易ID</span></span><br><span class="line">  <span class="title function_">getTransactionId</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txId</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取输出索引</span></span><br><span class="line">  <span class="title function_">getOutputIndex</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">outputIndex</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取地址</span></span><br><span class="line">  <span class="title function_">getAddress</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">address</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取金额</span></span><br><span class="line">  <span class="title function_">getAmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">amount</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新金额</span></span><br><span class="line">  <span class="title function_">updateAmount</span>(<span class="params">newAmount</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">amount</span> = newAmount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第一课</title>
      <link href="/post/4c73e1c2.html"/>
      <url>/post/4c73e1c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="pdf文件"><a href="#pdf文件" class="headerlink" title="pdf文件"></a>pdf文件</h1><p><a href="https://formikasaever.github.io/pdf/%E4%B8%89%E5%8F%B6%E8%8D%89%E5%AE%9E%E9%AA%8C%E5%AE%A4%E2%80%9C%E6%9C%9F%E6%9C%AB%E4%BB%BB%E5%8A%A1%E2%80%9D%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%89.pdf">https://formikasaever.github.io/pdf/%E4%B8%89%E5%8F%B6%E8%8D%89%E5%AE%9E%E9%AA%8C%E5%AE%A4%E2%80%9C%E6%9C%9F%E6%9C%AB%E4%BB%BB%E5%8A%A1%E2%80%9D%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%89.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第六课</title>
      <link href="/post/8cc639b3.html"/>
      <url>/post/8cc639b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”任务一-第六课"><a href="#三叶草实验室“期末任务”任务一-第六课" class="headerlink" title="三叶草实验室“期末任务”任务一(第六课)"></a>三叶草实验室“期末任务”任务一(第六课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="6-应用前端和Web3-js"><a href="#6-应用前端和Web3-js" class="headerlink" title="6.应用前端和Web3.js"></a>6.应用前端和Web3.js</h3><h4 id="①介绍-Web3-js"><a href="#①介绍-Web3-js" class="headerlink" title="①介绍 Web3.js"></a>①介绍 Web3.js</h4><p>完成第五课以后，我们的僵尸 DApp 的 Solidity 合约部分就完成了。现在我们来做一个基本的网页好让你的用户能玩它。 要做到这一点，我们将使用以太坊基金发布的 JavaScript 库 —— <code>Web3.js.</code></p><p><strong>什么是 Web3.js?</strong></p><p>还记得么？以太坊网络是由节点组成的，每一个节点都包含了区块链的一份拷贝。当你想要调用一份智能合约的一个方法，你需要从其中一个节点中查找并告诉它:</p><ol><li>智能合约的地址</li><li>你想调用的方法，以及</li><li>你想传入那个方法的参数</li></ol><p>以太坊节点只能识别一种叫做 <code>JSON-RPC</code> 的语言。这种语言直接读起来并不好懂。当你你想调用一个合约的方法的时候，需要发送的查询语句将会是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 哈……祝你写所有这样的函数调用的时候都一次通过</span><br><span class="line">// 往右边拉…… ==&gt;</span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;:[&#123;&quot;from&quot;:&quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;,&quot;to&quot;:&quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;,&quot;gas&quot;:&quot;0x76c0&quot;,&quot;gasPrice&quot;:&quot;0x9184e72a000&quot;,&quot;value&quot;:&quot;0x9184e72a&quot;,&quot;data&quot;:&quot;0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675&quot;&#125;],&quot;id&quot;:1&#125;</span><br></pre></td></tr></table></figure><p>幸运的是 Web3.js 把这些令人讨厌的查询语句都隐藏起来了， 所以你只需要与方便易懂的 JavaScript 界面进行交互即可。</p><p>你不需要构建上面的查询语句，在你的代码中调用一个函数看起来将是这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CryptoZombies.methods.createRandomZombie(&quot;Vitalik Nakamoto 🤔&quot;)</span><br><span class="line">  .send(&#123; from: &quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;, gas: &quot;3000000&quot; &#125;)</span><br></pre></td></tr></table></figure><p>我们将在接下来的几章详细解释这些语句，不过首先我们来把 Web3.js 环境搭建起来。</p><p><strong>准备好了么？</strong><br>取决于你的项目工作流程和你的爱好，你可以用一些常用工具把 Web3.js 添加进来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用 NPM</span><br><span class="line">npm install web3</span><br><span class="line"></span><br><span class="line">// 用 Yarn</span><br><span class="line">yarn add web3</span><br><span class="line"></span><br><span class="line">// 用 Bower</span><br><span class="line">bower install web3</span><br><span class="line"></span><br><span class="line">// ...或者其他。</span><br></pre></td></tr></table></figure><p>甚至，你可以从 <code>github</code> 直接下载压缩后的 <code>.js </code>文件 然后包含到你的项目文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;web3.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>因为我们不想让你花太多在项目环境搭建上，在本教程中我们将使用上面的 <code>script</code> 标签来将 Web3.js 引入。</p><p>实战演习：<br><strong>index.html:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;CryptoZombies front-end&lt;/title&gt;</span><br><span class="line">    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;web3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="②Web3-提供者"><a href="#②Web3-提供者" class="headerlink" title="②Web3 提供者"></a>②Web3 提供者</h4><hr><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第五课</title>
      <link href="/post/e9c8726a.html"/>
      <url>/post/e9c8726a.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”总结（续）-第五课"><a href="#三叶草实验室“期末任务”总结（续）-第五课" class="headerlink" title="三叶草实验室“期末任务”总结（续）(第五课)"></a>三叶草实验室“期末任务”总结（续）(第五课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="5-ERC721标准和加密收藏品"><a href="#5-ERC721标准和加密收藏品" class="headerlink" title="5.ERC721标准和加密收藏品"></a>5.ERC721标准和加密收藏品</h3><h4 id="①以太坊上的代币"><a href="#①以太坊上的代币" class="headerlink" title="①以太坊上的代币"></a>①以太坊上的代币</h4><p>让我们来聊聊 <em>代币</em>.</p><p>如果你对以太坊的世界有一些了解，你很可能听过人们聊到代币——尤其是 ERC20 代币.</p><p>一个 <em>代币</em> 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 <code>transfer(address _to, uint256 _value)</code> 和 <code>balanceOf(address _owner)</code>.</p><p>在智能合约内部，通常有一个映射，<code>mapping(address =&gt; uint256) balances</code>，用于追踪每个地址还有多少余额。</p><p>所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数。</p><p><strong>它为什么重要呢？</strong><br>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。</p><p>这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。</p><p>其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。</p><p>交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。</p><p><strong>其他代币标准</strong><br>对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。</p><p>首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。</p><p>其次，并不是所有僵尸都是平等的。 你的2级僵尸”Steve”完全不能等同于我732级的僵尸”H4XF13LD MORRIS 💯💯😎💯💯”。（你差得远呢，Steve）。</p><p>有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为ERC721 代币.</p><p>ERC721 代币是不能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p><blockquote><p>请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。</p></blockquote><p>实战演习:<br>zombieownership.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombieattack.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieOwnership is ZombieAttack &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②ERC721-标准-多重继承"><a href="#②ERC721-标准-多重继承" class="headerlink" title="②ERC721 标准, 多重继承"></a>②ERC721 标准, 多重继承</h4><p>让我们来看一看 ERC721 标准：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们需要实现的方法列表，我们将在接下来的章节中逐个学习。</p><p>虽然看起来很多，但不要被吓到了！我们在这里就是准备带着你一步一步了解它们的。</p><blockquote><p>注意： ERC721目前是一个 草稿，还没有正式商定的实现。在本教程中，我们使用的是 OpenZeppelin 库中的当前版本，但在未来正式发布之前它可能会有更改。 所以把这 一个 可能的实现当作考虑，但不要把它作为 ERC721 代币的官方标准。</p></blockquote><p><strong>实现一个代币合约</strong><br>在实现一个代币合约的时候，我们首先要做的是将接口复制到它自己的 Solidity 文件并导入它，<code>import &quot;./erc721.sol&quot;;</code>。 接着，让我们的合约继承它，然后我们用一个函数定义来重写每个方法。</p><p>但等一下—— <code>ZombieOwnership</code>已经继承自 <code>ZombieAttack</code>了 —— 它如何能够也继承于 <code>ERC721</code>呢？</p><p>幸运的是在Solidity，你的合约可以继承自多个合约，参考如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SatoshiNakamoto is NickSzabo, HalFinney &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见，当使用多重继承的时候，你只需要用逗号 , 来隔开几个你想要继承的合约。在上面的例子中，我们的合约继承自 <code>NickSzabo</code> 和 <code>HalFinney</code>。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombieattack.sol&quot;;</span><br><span class="line">import &quot;./erc721.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③balanceOf-和-ownerOf"><a href="#③balanceOf-和-ownerOf" class="headerlink" title="③balanceOf 和 ownerOf"></a>③balanceOf 和 ownerOf</h4><p>在本章节，我们将实现头两个方法： balanceOf 和 ownerOf。</p><p><strong>balanceOf</strong><br><code>function balanceOf(address _owner) public view returns (uint256 _balance);</code><br>这个函数只需要一个传入 address 参数，然后返回这个 address 拥有多少代币。</p><p>在我们的例子中，我们的“代币”是僵尸。你还记得在我们 DApp 的哪里存储了一个主人拥有多少只僵尸吗？</p><p><strong>ownerOf</strong></p><p><code>function ownerOf(uint256 _tokenId) public view returns (address _owner);</code><br>这个函数需要传入一个代币 ID 作为参数 (我们的情况就是一个僵尸 ID)，然后返回该代币拥有者的 address。</p><p>同样的，因为在我们的 DApp 里已经有一个 mapping (映射) 存储了这个信息，所以对我们来说这个实现非常直接清晰。我们可以只用一行 return 语句来实现这个函数。</p><blockquote><p>注意：要记得， uint256 等同于uint。我们从课程的开始一直在代码中使用 uint，但从现在开始我们将在这里用 uint256，因为我们直接从规范中复制粘贴。</p></blockquote><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function balanceOf(address _owner) public view returns (uint256 _balance) &#123;</span><br><span class="line">  return ownerZombieCount[_owner];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ownerOf(uint256 _tokenId) public view returns (address _owner) &#123;</span><br><span class="line">  return zombieToOwner[_tokenId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④重构"><a href="#④重构" class="headerlink" title="④重构"></a>④重构</h4><p>我们刚刚的代码中其实有个错误，以至于其根本无法通过编译，你发现了没？</p><p>在前一个章节我们定义了一个叫 ownerOf 的函数。但如果你还记得第4课的内容，我们同样在zombiefeeding.sol 里以 ownerOf 命名创建了一个 modifier（修饰符）。</p><p>如果你尝试编译这段代码，编译器会给你一个错误说你不能有相同名称的修饰符和函数。</p><p>所以我们应该把在 ZombieOwnership 里的函数名称改成别的吗？</p><p>不，我们不能那样做！！！要记得，我们正在用 ERC721 代币标准，意味着其他合约将期望我们的合约以这些确切的名称来定义函数。这就是这些标准实用的原因——如果另一个合约知道我们的合约符合 ERC721 标准，它可以直接与我们交互，而无需了解任何关于我们内部如何实现的细节。</p><p>所以，那意味着我们将必须重构我们第4课中的代码，将 modifier 的名称换成别的。</p><p>实战演习：<br>我们回到了 zombiefeeding.sol 。我们将把 modifier 的名称从 ownerOf 改成 onlyOwnerOf。</p><ol><li><p>把修饰符定义中的名称改成 onlyOwnerOf</p></li><li><p>往下滑到使用此修饰符的函数 feedAndMultiply 。我们也需要改这里的名称。</p></li></ol><blockquote><p>注意：我们在 zombiehelper.sol 和 zombieattack.sol 里也使用了这个修饰符，但为了不在这节课的重构里花太多时间，我们已经将那些文件里的修饰符名称为你改好了。</p></blockquote><h4 id="⑤ERC721-转移标准"><a href="#⑤ERC721-转移标准" class="headerlink" title="⑤ERC721: 转移标准"></a>⑤ERC721: 转移标准</h4><p>现在我们将通过学习把所有权从一个人转移给另一个人来继续我们的 ERC721 规范的实现。</p><p>注意 ERC721 规范有两种不同的方法来转移代币：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line"></span><br><span class="line">function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">function takeOwnership(uint256 _tokenId) public;</span><br></pre></td></tr></table></figure><ol><li><p>第一种方法是代币的拥有者调用transfer 方法，传入他想转移到的 address 和他想转移的代币的 _tokenId。</p></li><li><p>第二种方法是代币拥有者首先调用 approve，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 mapping (uint256 &#x3D;&gt; address) 里。然后，当有人调用 takeOwnership 时，合约会检查 msg.sender 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。</p></li></ol><p>你注意到了吗，transfer 和 takeOwnership 都将包含相同的转移逻辑，只是以相反的顺序。 （一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它）。</p><p>所以我们把这个逻辑抽象成它自己的私有函数 _transfer，然后由这两个函数来调用它。 这样我们就不用写重复的代码了。</p><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address _from, address _to, uint256 _tokenId) private &#123;</span><br><span class="line">    ownerZombieCount[_to]++;</span><br><span class="line">    ownerZombieCount[_from]--;</span><br><span class="line">    zombieToOwner[_tokenId] = _to;</span><br><span class="line">    Transfer(_from, _to, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥ERC721-转移-续"><a href="#⑥ERC721-转移-续" class="headerlink" title="⑥ERC721: 转移-续"></a>⑥ERC721: 转移-续</h4><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑦ERC721-批准"><a href="#⑦ERC721-批准" class="headerlink" title="⑦ERC721: 批准"></a>⑦ERC721: 批准</h4><p>现在，让我们来实现 approve。</p><p>记住，使用 approve 或者 takeOwnership 的时候，转移有2个步骤：</p><ol><li><p>你，作为所有者，用新主人的 address 和你希望他获取的 _tokenId 来调用 approve</p></li><li><p>新主人用 _tokenId 来调用 takeOwnership，合约会检查确保他获得了批准，然后把代币转移给他。</p></li></ol><p>因为这发生在2个函数的调用中，所以在函数调用之间，我们需要一个数据结构来存储什么人被批准获取什么。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (uint =&gt; address) zombieApprovals;</span><br><span class="line"></span><br><span class="line">function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    zombieApprovals[_tokenId] = _to;</span><br><span class="line">    Approval(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑧ERC721-takeOwnership"><a href="#⑧ERC721-takeOwnership" class="headerlink" title="⑧ERC721: takeOwnership"></a>⑧ERC721: takeOwnership</h4><p>最后一个函数 takeOwnership， 应该只是简单地检查以确保 msg.sender 已经被批准来提取这个代币或者僵尸。若确认，就调用 _transfer；</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function takeOwnership(uint256 _tokenId) public &#123;</span><br><span class="line">    require(zombieApprovals[_tokenId] == msg.sender);</span><br><span class="line">    address owner = ownerOf(_tokenId);</span><br><span class="line">    _transfer(owner, msg.sender, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑨预防溢出"><a href="#⑨预防溢出" class="headerlink" title="⑨预防溢出"></a>⑨预防溢出</h4><p>我们完成了 ERC721 的实现。</p><p>不过要记住那只是最简单的实现。还有很多的特性我们也许想加入到我们的实现中来，比如一些额外的检查，来确保用户不会不小心把他们的僵尸转移给0 地址（这被称作 “烧币”, 基本上就是把代币转移到一个谁也没有私钥的地址，让这个代币永远也无法恢复）。 或者在 DApp 中加入一些基本的拍卖逻辑。（你能想出一些实现的方法么？）</p><p>但是为了让我们的课程不至于离题太远，所以我们只专注于一些基础实现。如果你想学习一些更深层次的实现，可以在这个教程结束后，去看看 OpenZeppelin 的 ERC721 合约。</p><p><strong>合约安全增强: 溢出和下溢</strong><br>我们将来学习你在编写智能合约的时候需要注意的一个主要的安全特性：防止溢出和下溢。</p><p>什么是 <em>溢出</em> (overflow)?</p><p>假设我们有一个 uint8, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 11111111 (或者说十进制的 2^8 - 1 &#x3D; 255).</p><p>来看看下面的代码。最后 number 将会是什么值？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 number = 255;</span><br><span class="line">number++;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是 number 出乎意料地等于 0了。 (如果你给二进制 11111111 加1, 它将被重置为 00000000，就像钟表从 23:59 走向 00:00)。</p><p>下溢(underflow)也类似，如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。</p><p>虽然我们在这里不使用 uint8，而且每次给一个 uint256 加 1 也不太可能溢出 (2^256 真的是一个很大的数了)，在我们的合约中添加一些保护机制依然是非常有必要的，以防我们的 DApp 以后出现什么异常情况。</p><p><strong>使用 SafeMath</strong><br>为了防止这些情况，OpenZeppelin 建立了一个叫做 SafeMath 的 <em>库</em>(library)，默认情况下可以防止这些问题。</p><p>不过在我们使用之前…… 什么叫做库?</p><p>一个_库_ 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。</p><p>比如，使用 SafeMath 库的时候，我们将使用 using SafeMath for uint256 这样的语法。 SafeMath 库有四个方法 — add， sub， mul， 以及 div。现在我们可以这样来让 uint256 调用这些方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = 5;</span><br><span class="line">uint256 b = a.add(3); // 5 + 3 = 8</span><br><span class="line">uint256 c = a.mul(2); // 5 * 2 = 10</span><br></pre></td></tr></table></figure><p>我们将在下一章来学习这些方法，不过现在我们先将 SafeMath 库添加进我们的合约。</p><p>实战演习：</p><ol><li>将 safemath.sol 引入到 zombiefactory.sol.</li><li>添加定义： using SafeMath for uint256;.</li></ol><h4 id="⑩SafeMath第二部分"><a href="#⑩SafeMath第二部分" class="headerlink" title="⑩SafeMath第二部分"></a>⑩SafeMath第二部分</h4><p>来看看 SafeMath 的部分代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有了 library 关键字 — 库和 合约很相似，但是又有一些不同。 就我们的目的而言，库允许我们使用 using 关键字，它可以自动把库的所有方法添加给一个数据类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint;</span><br><span class="line">// 这下我们可以为任何 uint 调用这些方法了</span><br><span class="line">uint test = 2;</span><br><span class="line">test = test.mul(3); // test 等于 6 了</span><br><span class="line">test = test.add(5); // test 等于 11 了</span><br></pre></td></tr></table></figure><p>注意 mul 和 add 其实都需要两个参数。 在我们声明了 using SafeMath for uint 后，我们用来调用这些方法的 uint 就自动被作为第一个参数传递进去了(在此例中就是 test)</p><p>我们来看看 add 的源代码看 SafeMath 做了什么:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上 add 只是像 + 一样对两个 uint 相加， 但是它用一个 assert 语句来确保结果大于 a。这样就防止了溢出。</p><p>assert 和 require 相似，若结果为否它就会抛出错误。 assert 和 require 区别在于，require 若失败则会返还给用户剩下的 gas， assert 则不会。所以大部分情况下，你写代码的时候会比较喜欢 require，assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。</p><p>所以简而言之， SafeMath 的 add， sub， mul， 和 div 方法只做简单的四则运算，然后在发生溢出或下溢的时候抛出错误。</p><p><strong>在我们的代码里使用 SafeMath。</strong><br>为了防止溢出和下溢，我们可以在我们的代码里找 +， -， *， 或 &#x2F;，然后替换为 add, sub, mul, div.</p><p>比如，与其这样做:<code>myUint++;</code><br>我们这样做:<code>myUint = myUint.add(1);</code></p><p>实战演习：<br>    &#x2F;&#x2F; 1. 替换成 SafeMath 的 <code>add</code><br>    ownerZombieCount[_to]++;<br>    &#x2F;&#x2F; 2. 替换成 SafeMath 的 <code>sub</code><br>    ownerZombieCount[_from]–;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ownerZombieCount[_to] = ownerZombieCount[_to].add(1);</span><br><span class="line">ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);</span><br></pre></td></tr></table></figure><h4 id="⑪SafeMath-第三部分"><a href="#⑪SafeMath-第三部分" class="headerlink" title="⑪SafeMath 第三部分"></a>⑪SafeMath 第三部分</h4><p>太好了，这下我们的 ERC721 实现不会有溢出或者下溢了。</p><p>回头看看我们在之前课程写的代码，还有其他几个地方也有可能导致溢出或下溢。</p><p>比如， 在 ZombieAttack 里面我们有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myZombie.winCount++;</span><br><span class="line">myZombie.level++;</span><br><span class="line">enemyZombie.lossCount++;</span><br></pre></td></tr></table></figure><p>我们同样应该在这些地方防止溢出。（通常情况下，总是使用 SafeMath 而不是普通数学运算是个好主意，也许在以后 Solidity 的新版本里这点会被默认实现，但是现在我们得自己在代码里实现这些额外的安全措施）。</p><p>不过我们遇到个小问题 — winCount 和 lossCount 是 uint16， 而 level 是 uint32。 所以如果我们用这些作为参数传入 SafeMath 的 add 方法。 它实际上并不会防止溢出，因为它会把这些变量都转换成 uint256:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果我们在`uint8` 上调用 `.add`。它将会被转换成 `uint256`.</span><br><span class="line">// 所以它不会在 2^8 时溢出，因为 256 是一个有效的 `uint256`.</span><br></pre></td></tr></table></figure><p>这就意味着，我们需要再实现两个库来防止 uint16 和 uint32 溢出或下溢。我们可以将其命名为 SafeMath16 和 SafeMath32。</p><p>代码将和 SafeMath 完全相同，除了所有的 uint256 实例都将被替换成 uint32 或 uint16。</p><p>我们已经将这些代码帮你写好了，打开 safemath.sol 合约看看代码吧。</p><p>现在我们需要在 ZombieFactory 里使用它们。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line">using SafeMath32 for uint32;</span><br><span class="line">using SafeMath16 for uint16;</span><br></pre></td></tr></table></figure><h4 id="⑫SafeMath-第4部分"><a href="#⑫SafeMath-第4部分" class="headerlink" title="⑫SafeMath 第4部分"></a>⑫SafeMath 第4部分</h4><p>真棒，现在我们已经为我们的 DApp 里面用到的 uint 数据类型都实现了 SafeMath 了。</p><p>让我们把 ZombieAttack 里所有潜在的问题都修复了吧。 （其实在 ZombieHelper 里也有一处 zombies[_zombieId].level++; 需要修复，不过我们已经帮你做好了，这样我们就不用再来一章了 😉）。</p><h4 id="⑬注释"><a href="#⑬注释" class="headerlink" title="⑬注释"></a>⑬注释</h4><p>僵尸游戏的 Solidity 代码终于完成啦。</p><p>在以后的课程中，我们将学习如何将游戏部署到以太坊，以及如何和 Web3.js 交互。</p><p>不过在你离开第五课之前，我们来谈谈如何 给你的代码添加注释.</p><p><strong>注释语法</strong><br>Solidity 里的注释和 JavaScript 相同。在我们的课程中你已经看到了不少单行注释了：</p><p><code>// 这是一个单行注释，可以理解为给自己或者别人看的笔记</code></p><p>只要在任何地方添加一个 &#x2F;&#x2F; 就意味着你在注释。如此简单所以你应该经常这么做。</p><p>不过我们也知道你的想法：有时候单行注释是不够的。毕竟你生来话痨。</p><p>所以我们有了多行注释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract CryptoZombies &#123;</span><br><span class="line">  /* 这是一个多行注释。我想对所有花时间来尝试这个编程课程的人说声谢谢。</span><br><span class="line">  它是免费的，并将永远免费。但是我们依然倾注了我们的心血来让它变得更好。</span><br><span class="line"></span><br><span class="line">   要知道这依然只是区块链开发的开始而已，虽然我们已经走了很远，</span><br><span class="line">   仍然有很多种方式来让我们的社区变得更好。</span><br><span class="line">   如果我们在哪个地方出了错，欢迎在我们的 github 提交 PR 或者 issue 来帮助我们改进：</span><br><span class="line">    https://github.com/loomnetwork/cryptozombie-lessons</span><br><span class="line"></span><br><span class="line">    或者，如果你有任何的想法、建议甚至仅仅想和我们打声招呼，欢迎来我们的电报群：</span><br><span class="line">     https://t.me/loomnetworkdev</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别是，最好为你合约中每个方法添加注释来解释它的预期行为。这样其他开发者（或者你自己，在6个月以后再回到这个项目中）可以很快地理解你的代码而不需要逐行阅读所有代码。</p><p>Solidity 社区所使用的一个标准是使用一种被称作 natspec 的格式，看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @title 一个简单的基础运算合约</span><br><span class="line">/// @author H4XF13LD MORRIS 💯💯😎💯💯</span><br><span class="line">/// @notice 现在，这个合约只添加一个乘法</span><br><span class="line">contract Math &#123;</span><br><span class="line">  /// @notice 两个数相乘</span><br><span class="line">  /// @param x 第一个 uint</span><br><span class="line">  /// @param y  第二个 uint</span><br><span class="line">  /// @return z  (x * y) 的结果</span><br><span class="line">  /// @dev 现在这个方法不检查溢出</span><br><span class="line">  function multiply(uint x, uint y) returns (uint z) &#123;</span><br><span class="line">    // 这只是个普通的注释，不会被 natspec 解释</span><br><span class="line">    z = x * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@title（标题） 和 @author （作者）很直接了.</li><li>@notice （须知）向 用户 解释这个方法或者合约是做什么的。 @dev （开发者） 是向开发者解释更多的细节。</li><li>@param （参数）和 @return （返回） 用来描述这个方法需要传入什么参数以及返回什么值。</li></ol><p>注意你并不需要每次都用上所有的标签，它们都是可选的。不过最少，写下一个 @dev 注释来解释每个方法是做什么的。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @title 一个管理转移僵尸所有权的合约</span><br><span class="line">/// @author formikasaever</span><br><span class="line">/// @dev 符合 OpenZeppelin 对 ERC721 标准草案的实现</span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 &#123;</span><br></pre></td></tr></table></figure><h4 id="⑭放在一起"><a href="#⑭放在一起" class="headerlink" title="⑭放在一起"></a>⑭放在一起</h4><p><strong>总结一下</strong><br>这节课里面我们学到了</p><ul><li>代币, ERC721 标准，以及可交易的物件&#x2F;僵尸</li><li>库以及如何使用库</li><li>如何利用 SafeMath 来防止溢出和下溢</li><li>代码注释和 natspec 标准</li></ul><p>这节教程完成了我们游戏的 Solidity 代码（仅针对当下来说，未来的课程我们也许会加入更多进去）。</p><p>在接下来的两节课中，我们将学习如何将游戏部署到以太坊以及和 web3.js 交互 （这样你就能为你的 DApp 打造一个界面了 ）。</p><h4 id="⑮第五课完成"><a href="#⑮第五课完成" class="headerlink" title="⑮第五课完成"></a>⑮第五课完成</h4><p>截至第五课完成，所有代码如下：<br><strong>zombieownership.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombieattack.sol&quot;;</span><br><span class="line">import &quot;./erc721.sol&quot;;</span><br><span class="line">import &quot;./safemath.sol&quot;;</span><br><span class="line"></span><br><span class="line">/// @title 一个管理转移僵尸所有权的合约</span><br><span class="line">/// @author formikasaever</span><br><span class="line">/// @dev 符合 OpenZeppelin 对 ERC721 标准草案的实现</span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  mapping (uint =&gt; address) zombieApprovals;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance) &#123;</span><br><span class="line">    return ownerZombieCount[_owner];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner) &#123;</span><br><span class="line">    return zombieToOwner[_tokenId];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _transfer(address _from, address _to, uint256 _tokenId) private &#123;</span><br><span class="line">    ownerZombieCount[_to] = ownerZombieCount[_to].add(1);</span><br><span class="line">    ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);</span><br><span class="line">    zombieToOwner[_tokenId] = _to;</span><br><span class="line">    Transfer(_from, _to, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    zombieApprovals[_tokenId] = _to;</span><br><span class="line">    Approval(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function takeOwnership(uint256 _tokenId) public &#123;</span><br><span class="line">    require(zombieApprovals[_tokenId] == msg.sender);</span><br><span class="line">    address owner = ownerOf(_tokenId);</span><br><span class="line">    _transfer(owner, msg.sender, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombieattack.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiehelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) &#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiehelper.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner &#123;</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function levelUp(uint _zombieId) external payable &#123;</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefeeding.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwnerOf(uint _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">      return (_zombie.readyTime &lt;= now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefactory.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line">import &quot;./safemath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">  uint dnaDigits = 16;</span><br><span class="line">  uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">  uint cooldownTime = 1 days;</span><br><span class="line"></span><br><span class="line">  struct Zombie &#123;</span><br><span class="line">    string name;</span><br><span class="line">    uint dna;</span><br><span class="line">    uint32 level;</span><br><span class="line">    uint32 readyTime;</span><br><span class="line">    uint16 winCount;</span><br><span class="line">    uint16 lossCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">  mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">  mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">  function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">    uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br><span class="line">    zombieToOwner[id] = msg.sender;</span><br><span class="line">    ownerZombieCount[msg.sender]++;</span><br><span class="line">    NewZombie(id, _name, _dna);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">    uint rand = uint(keccak256(_str));</span><br><span class="line">    return rand % dnaModulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function createRandomZombie(string _name) public &#123;</span><br><span class="line">    require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">    uint randDna = _generateRandomDna(_name);</span><br><span class="line">    randDna = randDna - randDna % 100;</span><br><span class="line">    _createZombie(_name, randDna);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ownable.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>safemath.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that throw on error</span><br><span class="line"> */</span><br><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Multiplies two numbers, throws on overflow.</span><br><span class="line">  */</span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Integer division of two numbers, truncating the quotient.</span><br><span class="line">  */</span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).</span><br><span class="line">  */</span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Adds two numbers, throws on overflow.</span><br><span class="line">  */</span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>erc721.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第四课</title>
      <link href="/post/8656b72d.html"/>
      <url>/post/8656b72d.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”总结（续）-第四课"><a href="#三叶草实验室“期末任务”总结（续）-第四课" class="headerlink" title="三叶草实验室“期末任务”总结（续）(第四课)"></a>三叶草实验室“期末任务”总结（续）(第四课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="4-僵尸作战系统"><a href="#4-僵尸作战系统" class="headerlink" title="4.僵尸作战系统"></a>4.僵尸作战系统</h3><h4 id="①可支付"><a href="#①可支付" class="headerlink" title="①可支付"></a>①可支付</h4><p>截至目前，我们只接触到很少的 函数修饰符。 要记住所有的东西很难，所以我们来个概览：</p><ol><li><p>我们有决定函数何时和被谁调用的可见性修饰符: private 意味着它只能被合约内部调用； internal 就像 private 但是也能被继承的合约调用； external 只能从合约外部调用；最后 public 可以在任何地方调用，不管是内部还是外部。</p></li><li><p>我们也有状态修饰符， 告诉我们函数如何和区块链交互: view 告诉我们运行这个函数不会更改和保存任何数据； pure 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</p></li><li><p>然后我们有了自定义的 modifiers，例如在第三课学习的: onlyOwner 和 aboveLevel。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</p></li></ol><p>这些修饰符可以同时作用于一个函数定义上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() external view onlyOwner anotherModifier &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><p>在这一章，我们来学习一个新的修饰符 payable.</p><p><strong>payable 修饰符</strong></p><p>payable 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。</p><p>先放一下。当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。</p><p>但是在以太坊中， 因为钱 (<em>以太</em>), 数据 (事务负载)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 并付钱给另外一个合约。</p><p>这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。</p><p><strong>来看个例子</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  function buySomething() external payable &#123;</span><br><span class="line">    // 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value == 0.001 ether);</span><br><span class="line">    // 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，msg.value 是一种可以查看向合约发送了多少以太的方法，另外 ether 是一个內建单元。</p><p>这里发生的事是，一些人会从 web3.js 调用这个函数 (从DApp的前端)， 像这样 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 假设 `OnlineStore` 在以太坊上指向你的合约:</span><br><span class="line">OnlineStore.buySomething().send(from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001))</span><br></pre></td></tr></table></figure><p>注意这个 value 字段， JavaScript 调用来指定发送多少(0.001)以太。如果把事务想象成一个信封，你发送到函数的参数就是信的内容。 添加一个 value 很像在信封里面放钱 —— 信件内容和钱同时发送给了接收者。</p><blockquote><p>注意： 如果一个函数没标记为payable， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p></blockquote><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">function levelUp(uint _zombieId) external payable &#123;</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②提现"><a href="#②提现" class="headerlink" title="②提现"></a>②提现</h4><p>在你发送以太之后，它将被存储进以合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p><p>你可以写一个函数来从合约中提现以太，类似这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用 Ownable 合约中的 owner 和 onlyOwner，假定它已经被引入了。</p><p>你可以通过 transfer 函数向一个地址发送以太， 然后 this.balance 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， this.balance 将是100以太。</p><p>你可以通过 transfer 向任何以太坊地址付钱。 比如，你可以有一个函数在 msg.sender 超额付款的时候给他们退钱：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint itemFee = 0.001 ether;</span><br><span class="line">msg.sender.transfer(msg.value - itemFee);</span><br></pre></td></tr></table></figure><p>或者在一个有卖家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 seller.transfer(msg.value)。</p><p>有很多例子来展示什么让以太坊编程如此之酷 —— 你可以拥有一个不被任何人控制的去中心化市场。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner &#123;</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="③僵尸战斗"><a href="#③僵尸战斗" class="headerlink" title="③僵尸战斗"></a>③僵尸战斗</h4><p>在我们学习了可支付函数和合约余额之后，是时候为僵尸战斗添加功能了。</p><p>遵循上一章的格式，我们新建一个攻击功能合约，并将代码放进新的文件中，引入上一个合约。<br>实战演习：<br>zombieattack.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiehelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④随机数"><a href="#④随机数" class="headerlink" title="④随机数"></a>④随机数</h4><p><strong>用 keccak256 来制造随机数。</strong><br>Solidity 中最好的随机数生成器是 keccak256 哈希函数.</p><p>我们可以这样来生成一些随机数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成一个0到100的随机数:</span><br><span class="line">uint randNonce = 0;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></table></figure><p>这个方法首先拿到 now 的时间戳、 msg.sender、 以及一个自增数 nonce （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p><p>然后利用 keccak 把输入的值转变为一个哈希值, 再将哈希值转换为 uint, 然后利用 % 100 来取最后两位, 就生成了一个0到100之间随机数了。</p><p><strong>这个方法很容易被不诚实的节点攻击</strong><br>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 transaction 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 block 发布在网络上。</p><p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p><p>这就让我们的随机数函数变得可利用了</p><p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (random &gt;&#x3D; 50 算正面, random &lt; 50 算反面)。</p><p>如果我正运行一个节点，我可以 只对我自己的节点 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p><p><strong>所以我们该如何在以太坊上安全地生成随机数呢</strong><br>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 这个 StackOverflow 上的讨论 来获得一些主意。 一个方法是利用 oracle 来访问以太坊区块链之外的随机数函数。</p><p>当然， 因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p><p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p><p>因为在这个教程中，我们只是在编写一个简单的游戏来做演示，也没有真正的钱在里面，所以我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint randNonce = 0;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) &#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤僵尸对决"><a href="#⑤僵尸对决" class="headerlink" title="⑤僵尸对决"></a>⑤僵尸对决</h4><p>我们的合约已经有了一些随机性的来源，可以用进我们的僵尸战斗中去计算结果。</p><p>我们的僵尸战斗看起来将是这个流程：</p><ul><li>你选择一个自己的僵尸，然后选择一个对手的僵尸去攻击。</li><li>如果你是攻击方，你将有70%的几率获胜，防守方将有30%的几率获胜。</li><li>所有的僵尸（攻守双方）都将有一个 winCount 和一个 lossCount，这两个值都将根据战斗结果增长。</li><li>若攻击方获胜，这个僵尸将升级并产生一个新僵尸。</li><li>如果攻击方失败，除了失败次数将加一外，什么都不会发生。</li><li>无论输赢，当前僵尸的冷却时间都将被激活。</li></ul><p>这有一大堆的逻辑需要处理，我们将把这些步骤分解到接下来的课程中去。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在这里创建 attackVictoryProbability</span><br><span class="line">uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">// 在这里创建新函数</span><br><span class="line">function attack(uint _zombieId, uint _targetId) external &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥重构通用逻辑"><a href="#⑥重构通用逻辑" class="headerlink" title="⑥重构通用逻辑"></a>⑥重构通用逻辑</h4><p>不管谁调用我们的 attack 函数 —— 我们想确保用户的确拥有他们用来攻击的僵尸。如果你能用其他人的僵尸来攻击将是一个很大的安全问题。</p><p>你能想一下我们如何添加一个检查步骤来看看调用这个函数的人就是他们传入的 _zombieId 的拥有者么？</p><p>想一想，看看你能不能自己找到一些答案。</p><p>花点时间…… 参考我们前面课程的代码来获得灵感。</p><p><strong>答案</strong><br>我们在前面的课程里面已经做过很多次这样的检查了。 在 changeName(), changeDna(), 和 feedAndMultiply()里，我们做过这样的检查：</p><p>require(msg.sender &#x3D;&#x3D; zombieToOwner[_zombieId]);<br>这和我们 attack 函数将要用到的检查逻辑是相同的。 正因我们要多次调用这个检查逻辑，让我们把它移到它自己的 modifier 中来清理代码并避免重复编码。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 在这里创建 modifier</span><br><span class="line">modifier ownerOf(uint _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 2. 在函数定义时增加 modifier :</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) &#123;</span><br><span class="line">    // 3. 移除这一行</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br></pre></td></tr></table></figure><h4 id="⑦更多重构"><a href="#⑦更多重构" class="headerlink" title="⑦更多重构"></a>⑦更多重构</h4><p>在 zombiehelper.sol里有几处地方，需要我们实现我们新的 modifier—— ownerOf。</p><p>实战演习：</p><ol><li><p>修改 changeName() 使其使用 ownerOf</p></li><li><p>修改 changeDna() 使其使用 ownerOf</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在changeName()函数与changeDna()函数的aboveLevel修饰符后面</span><br><span class="line">写上ownerOf(_zombieId)</span><br><span class="line">并删除两个函数中的</span><br><span class="line">require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">这一行代码即可</span><br></pre></td></tr></table></figure></li></ol><h4 id="⑧回到攻击"><a href="#⑧回到攻击" class="headerlink" title="⑧回到攻击"></a>⑧回到攻击</h4><p>重构完成了，回到 zombieattack.sol。</p><p>继续来完善我们的 attack 函数， 现在我们有了 ownerOf 修饰符来用了。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑨僵尸的输赢"><a href="#⑨僵尸的输赢" class="headerlink" title="⑨僵尸的输赢"></a>⑨僵尸的输赢</h4><p>对我们的僵尸游戏来说，我们将要追踪我们的僵尸输赢了多少场。有了这个我们可以在游戏里维护一个 “僵尸排行榜”。</p><p>有多种方法在我们的DApp里面保存一个数值 — 作为一个单独的映射，作为一个“排行榜”结构体，或者保存在 Zombie 结构体内。</p><p>每个方法都有其优缺点，取决于我们打算如何和这些数据打交道。在这个教程中，简单起见我们将这个状态保存在 Zombie 结构体中，将其命名为 winCount 和 lossCount。</p><p>我们跳回 zombiefactory.sol, 将这些属性添加进 Zombie 结构体.</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Zombie &#123;</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">      uint16 winCount;</span><br><span class="line">      uint16 lossCount;</span><br><span class="line">    &#125;</span><br><span class="line">// 2. 在这里修改修改新僵尸的创建:</span><br><span class="line">uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br></pre></td></tr></table></figure><h4 id="⑩僵尸胜利了😄"><a href="#⑩僵尸胜利了😄" class="headerlink" title="⑩僵尸胜利了😄"></a>⑩僵尸胜利了😄</h4><p>有了 winCount 和 lossCount，我们可以根据僵尸哪个僵尸赢了战斗来更新它们了。</p><p>在第六章我们计算出来一个0到100的随机数。现在让我们用那个数来决定那谁赢了战斗，并以此更新我们的状态。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">  myZombie.winCount++;</span><br><span class="line">  myZombie.level++;</span><br><span class="line">  enemyZombie.lossCount++;</span><br><span class="line">  feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑪僵尸失败😞"><a href="#⑪僵尸失败😞" class="headerlink" title="⑪僵尸失败😞"></a>⑪僵尸失败😞</h4><p>我们已经编写了你的僵尸赢了之后会发生什么， 该看看 输了 的时候要怎么做了。</p><p>在我们的游戏中，僵尸输了后并不会降级 —— 只是简单地给 lossCount 加一，并触发冷却，等待一天后才能再次参战。</p><p>要实现这个逻辑，我们需要一个 else 语句。</p><p>else 语句和 JavaScript 以及很多其他语言的 else 语句一样。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (zombieCoins[msg.sender] &gt; 100000000) &#123;</span><br><span class="line">  // 你好有钱!!!</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 我们需要更多的僵尸币...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">  myZombie.lossCount++;</span><br><span class="line">  enemyZombie.winCount++;</span><br><span class="line">  _triggerCooldown(myZombie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑫放在一起"><a href="#⑫放在一起" class="headerlink" title="⑫放在一起"></a>⑫放在一起</h4><p><strong>认领你的战利品</strong><br>在赢了战斗之后：</p><ol><li><p>你的僵尸将会升级</p></li><li><p>你僵尸的 winCount 将会增加</p></li><li><p>你将为你的僵尸大军获得一个新的僵尸</p></li></ol><h4 id="⑬Lesson-4-Complete！"><a href="#⑬Lesson-4-Complete！" class="headerlink" title="⑬Lesson 4 Complete！"></a>⑬Lesson 4 Complete！</h4><p>截至第四课完成，所有代码如下：<br><strong>zombieattack.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiehelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) &#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiehelper.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner &#123;</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function levelUp(uint _zombieId) external payable &#123;</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefeeding.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  modifier ownerOf(uint _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">      return (_zombie.readyTime &lt;= now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefactory.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    uint cooldownTime = 1 days;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">      uint16 winCount;</span><br><span class="line">      uint16 lossCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">    mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        randDna = randDna - randDna % 100;</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ownable.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="①第四课-第⑩节"><a href="#①第四课-第⑩节" class="headerlink" title="①第四课 第⑩节"></a>①第四课 第⑩节</h4><p>实战演习中if语句的最后一行<br>feedAndMultiply(_zombieId, enemyZombie.dna, “zombie”);<br>第二个传入’feedAndMultiply’函数的参数<br>为什么是enemyZombie.dna</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第二、三课</title>
      <link href="/post/d9a0b533.html"/>
      <url>/post/d9a0b533.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”总结（续）-第二课，第三课"><a href="#三叶草实验室“期末任务”总结（续）-第二课，第三课" class="headerlink" title="三叶草实验室“期末任务”总结（续）(第二课，第三课)"></a>三叶草实验室“期末任务”总结（续）(第二课，第三课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="2-僵尸攻击人类"><a href="#2-僵尸攻击人类" class="headerlink" title="2.僵尸攻击人类"></a>2.僵尸攻击人类</h3><h4 id="①第二课概览"><a href="#①第二课概览" class="headerlink" title="①第二课概览"></a>①第二课概览</h4><p>僵尸猎食<br>僵尸猎食的时候，僵尸病毒侵入猎物，这些病毒会将猎物变为新的僵尸，加入你的僵尸大军。系统会通 过猎物和猎食者僵尸的DNA计算出新僵尸的DNA。</p><h4 id="②映射（Mapping）和地址（Address）"><a href="#②映射（Mapping）和地址（Address）" class="headerlink" title="②映射（Mapping）和地址（Address）"></a>②映射（Mapping）和地址（Address）</h4><p>我们需要引入2个新的数据类型：mapping（映射） 和 address（地址）。</p><p>Addresses （地址）<br>以太坊区块链由 _ account _ (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <em>以太</em> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p><p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p><p>0x0cE446255506E92DF41614C46F1d6df9Cc969183</p><p>我们将在后面的课程中介绍地址的细节，现在你只需要了解地址属于特定用户（或智能合约）的。</p><p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p><p>Mapping（映射）<br>映射是这样定义的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></table></figure><p>映射本质上是存储和查找数据所用的键-值对。在第一个例子中，键是一个 address，值是一个 uint，在第二个例子中，键是一个uint，值是一个 string。</p><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">mapping (address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></table></figure><h4 id="③Msg-sender"><a href="#③Msg-sender" class="headerlink" title="③Msg.sender"></a>③Msg.sender</h4><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 msg.sender，它指的是当前调用者（或智能合约）的 address。</p><p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 msg.sender总是存在的。</p><p>以下是使用 msg.sender 来更新 mapping 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public &#123;</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) &#123;</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个小小的例子中，任何人都可以调用 setMyNumber 在我们的合约中存下一个 uint 并且与他们的地址相绑定。 然后，他们调用 whatIsMyNumber 就会返回他们存储的 uint。</p><p>使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">    uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">    zombieToOwner[id] = msg.sender;</span><br><span class="line">    ownerZombieCount[msg.sender]++;</span><br><span class="line">    NewZombie(id, _name, _dna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####④Require<br>require使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) &#123;</span><br><span class="line">  // 比较 _name 是否等于 &quot;Vitalik&quot;. 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return &quot;Hi!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你这样调用函数 sayHiToVitalik（“Vitalik”） ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p><p>因此，在调用一个函数之前，用 require 验证前置条件是非常有必要的。</p><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>####⑤继承（Inheritance）<br>个让 Solidity 的代码易于管理的功能，就是合约 inheritance (继承)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Doge &#123;</span><br><span class="line">  function catchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;So Wow CryptoDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge &#123;</span><br><span class="line">  function anotherCatchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;Such Moon BabyDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 BabyDoge 是从 Doge 那里 inherits （继承)过来的。 这意味着当你编译和部署了 BabyDoge，它将可以访问 catchphrase() 和 anotherCatchphrase()和其他我们在 Doge 中定义的其他公共函数。<br>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####⑥引入（Import）<br>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 import 语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;./someothercontract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们在合约（contract）目录下有一个名为 someothercontract.sol 的文件（ .&#x2F; 就是同一目录的意思），它就会被编译器导入。</p><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####⑦Storage与Memory<br>在 Solidity 中，有两个地方可以存储变量 —— storage 或 memory。</p><p>Storage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p><p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p><p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 _ 结构体 _ 和 _ 数组 _ 时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">  struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public &#123;</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还没有完全理解究竟应该使用哪一个,Solidity 编译器会发警示提醒你的。</p><p>实战演示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>####⑧僵尸的DNA<br>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testDnaSplicing() public &#123;</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑨更多关于函数可见性"><a href="#⑨更多关于函数可见性" class="headerlink" title="⑨更多关于函数可见性"></a>⑨更多关于函数可见性</h4><p>internal 和 external<br>除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。</p><p>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</p><p>external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。</p><p>声明函数 internal 或 external 类型的语法，与声明 private 和 public类 型相同：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Sandwich &#123;</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal &#123;</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich &#123;</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) &#123;</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习:将 _createZombie() 函数的属性从 private 改为 internal</p><h4 id="⑩僵尸吃什么"><a href="#⑩僵尸吃什么" class="headerlink" title="⑩僵尸吃什么?"></a>⑩僵尸吃什么?</h4><p>与其他合约的交互：<br>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。</p><p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract LuckyNumber &#123;</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public &#123;</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) &#123;</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p><p>现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。</p><p>首先，我们定义 LuckyNumber 合约的 interface ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p><p>首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。</p><p>其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。</p><p>编译器就是靠这些特征认出它是一个接口的。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑪使用接口"><a href="#⑪使用接口" class="headerlink" title="⑪使用接口"></a>⑪使用接口</h4><p>继续前面 NumberInterface 的例子，我们既然将接口定义为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在合约中这样使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract MyContract &#123;</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public &#123;</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，只要将您合约的可见性设置为public(公共)或external(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KittyInterface kittyContract = KittyInterface(ckAddress);</span><br></pre></td></tr></table></figure><h4 id="⑫处理多返回值"><a href="#⑫处理多返回值" class="headerlink" title="⑫处理多返回值"></a>⑫处理多返回值</h4><p>getKitty 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) &#123;</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external &#123;</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑬奖励-Kitty-基因"><a href="#⑬奖励-Kitty-基因" class="headerlink" title="⑬奖励: Kitty 基因"></a>⑬奖励: Kitty 基因</h4><p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p><p>这样吧，把猫僵尸DNA的最后两个数字设定为99（因为猫有9条命）。所以在我们这么来写代码：如果这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为99。</p><p>if 语句<br>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function eatBLT(string sandwich) public &#123;</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256(&quot;BLT&quot;)) &#123;</span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑭放在一起"><a href="#⑭放在一起" class="headerlink" title="⑭放在一起"></a>⑭放在一起</h4><p>JavaScript 实现<br>我们只用编译和部署 ZombieFeeding，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 ZombieFactory，因此它可以访问自己和父辈合约中的所有 public 方法。</p><p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = &quot;https://api.cryptokitties.co/kitties/&quot; + kittyId</span><br><span class="line">$.get(apiUrl, function(data) &#123;</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(&quot;.kittyImage&quot;).click(function(e) &#123;</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) &#123;</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="⑮第二课完成"><a href="#⑮第二课完成" class="headerlink" title="⑮第二课完成"></a>⑮第二课完成</h4><p>截至第二课完成，所有代码如下：<br>zombiefactory.sol</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">    mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        randDna = randDna - randDna % 100;</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zombiefeeding.sol</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-高级-Solidity-理论"><a href="#3-高级-Solidity-理论" class="headerlink" title="3.高级 Solidity 理论"></a>3.高级 Solidity 理论</h3><h4 id="①智能协议的永固性"><a href="#①智能协议的永固性" class="headerlink" title="①智能协议的永固性"></a>①智能协议的永固性</h4><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p><p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p><p>第一个例子，在你把智能协议传上以太坊之后，它就变得不可更改, 这种永固性意味着你的代码永远不能被调整或更新。</p><p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p><p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p><p>外部依赖关系：<br>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p><p>因此，我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p><p>比方说，我们不再一开始就把猎物地址给写入代码，而是写个函数 setKittyContractAddress, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="②Ownable-Contracts"><a href="#②Ownable-Contracts" class="headerlink" title="②Ownable Contracts"></a>②Ownable Contracts</h4><p>OpenZeppelin库的Ownable 合约<br>下面是一个 Ownable 合约的例子： 来自 _ OpenZeppelin _ Solidity 库的 Ownable 合约。 OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看，保管您会学到很多东西！</p><p>把楼下这个合约读读通，是不是还有些没见过代码？别担心，我们随后会解释。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造函数：function Ownable()是一个 _ constructor_ (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li><li>函数修饰符：modifier onlyOwner()。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 onlyOwner 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的_;。</li><li>indexed 关键字：别担心，我们还用不到它。</li></ol><p>所以Ownable 合约基本都会这么干：</p><ol><li>合约创建，构造函数先行，将其 owner 设置为msg.sender（其部署者）</li><li>为它加上一个修饰符 onlyOwner，它会限制陌生人的访问，将访问某些函数的权限锁定在 owner 上。</li><li>允许将合约所有权转让给他人。</li></ol><p>onlyOwner 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制&#x2F;粘贴 Ownable 开始的，从它再继承出的子类，并在之上进行功能开发。</p><p>既然我们想把 setKittyContractAddress 限制为 onlyOwner ，我们也要做同样的事情。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br></pre></td></tr></table></figure><h4 id="③onlyOwner-函数修饰符"><a href="#③onlyOwner-函数修饰符" class="headerlink" title="③onlyOwner 函数修饰符"></a>③onlyOwner 函数修饰符</h4><p>现在我们有了个基本版的合约 ZombieFactory 了，它继承自 Ownable 接口，我们也可以给 ZombieFeeding 加上 onlyOwner 函数修饰符。</p><p>这就是合约继承的工作原理。记得：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZombieFeeding 是个 ZombieFactory</span><br><span class="line">ZombieFactory 是个 Ownable</span><br></pre></td></tr></table></figure><p>因此 ZombieFeeding 也是个 Ownable, 并可以通过 Ownable 接口访问父类中的函数&#x2F;事件&#x2F;修饰符。往后，ZombieFeeding 的继承者合约们同样也可以这么延续下去。</p><p><strong>函数修饰符</strong><br>函数修饰符看起来跟函数没什么不同，不过关键字modifier 告诉编译器，这是个modifier(修饰符)，而不是个function(函数)。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p><p>咱们仔细读读 onlyOwner:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> */</span><br><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">  require(msg.sender == owner);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onlyOwner 函数修饰符是这么用的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 likeABoss 函数上的 onlyOwner 修饰符。 当你调用 likeABoss 时，首先执行 onlyOwner 中的代码， 执行到 onlyOwner 中的 _; 语句时，程序再返回并执行 likeABoss 中的代码。</p><p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 require检查。</p><p>因为给函数添加了修饰符 onlyOwner，使得唯有合约的主人（也就是部署者）才能调用它。</p><blockquote><p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p></blockquote><blockquote><p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。<br>实战演习：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改这个函数:</span><br><span class="line">function setKittyContractAddress(address _address) external &#123;</span><br><span class="line">//修改后：</span><br><span class="line">function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br></pre></td></tr></table></figure><h4 id="④Gas"><a href="#④Gas" class="headerlink" title="④Gas"></a>④Gas</h4><p><strong>Gas - 驱动以太坊DApps的能源</strong><br>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 gas，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p><p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 gas 等于这个操作背后的所有运算花销的总和。</p><p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来，运行花费更高，这显然会给成千上万的用户带来大量不必要的开销。<br><strong>为什么要用 gas 来驱动？</strong><br>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p><p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p><blockquote><p>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</p></blockquote><p><strong>省 gas 的招数：结构封装 （Struct packing）</strong><br>在第1课中，我们提到除了基本版的 uint 外，还有其他变种 uint：uint8，uint16，uint32等。</p><p>通常情况下我们不会考虑使用 uint 变种，因为无论如何定义 uint的大小，Solidity 为它保留256位的存储空间。例如，使用 uint8 而不是uint（uint256）不会为你节省任何 gas。</p><p>除非，把 uint 绑定到 struct 里面。</p><p>如果一个 struct 中有多个 uint，则尽可能使用较小的 uint, Solidity 会将这些 uint 打包在一起，从而占用较少的存储空间。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span><br><span class="line">NormalStruct normal = NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini = MiniMe(10, 20, 30); </span><br></pre></td></tr></table></figure><p>所以，当 uint 定义在一个 struct 中的时候，尽量使用最小的整数子类型以节约空间。 并且把同样类型的变量放一起（即在 struct 中将把变量按照类型依次放置），这样 Solidity 可以将存储空间最小化。例如，有两个 struct：</p><p>uint c; uint32 a; uint32 b; 和 uint32 a; uint c; uint32 b;</p><p>前者比后者需要的gas更少，因为前者把uint32放一起了。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">        uint32 level;</span><br><span class="line">        uint32 readyTime;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤时间单位"><a href="#⑤时间单位" class="headerlink" title="⑤时间单位"></a>⑤时间单位</h4><p>level 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p><p>readyTime 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p><p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。<br><strong>时间单位</strong><br>Solidity 使用自己的本地时间单位。</p><p>变量 now 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 1515527488。</p><blockquote><p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p></blockquote><p>Solidity 还包含秒(seconds)，分钟(minutes)，小时(hours)，天(days)，周(weeks) 和 年(years) 等时间单位。它们都会转换成对应的秒数放入 uint 中。所以 1分钟 就是 60，1小时是 3600（60秒×60分钟），1天是86400（24小时×60分钟×60秒），以此类推。</p><p>下面是一些使用时间单位的实用案例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public &#123;</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 &#x27;true&#x27;</span><br><span class="line">// 不到5分钟返回 &#x27;false&#x27;</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) &#123;</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 在这里定义 `cooldownTime`</span><br><span class="line"></span><br><span class="line">// 2. 修改下面这行:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">// uint cooldownTime = 1 days;</span><br><span class="line">   uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br></pre></td></tr></table></figure><h4 id="⑥僵尸冷却"><a href="#⑥僵尸冷却" class="headerlink" title="⑥僵尸冷却"></a>⑥僵尸冷却</h4><p>现在，Zombie 结构体中定义好了一个 readyTime 属性，让我们跳到 zombiefeeding.sol， 去实现一个”冷却周期定时器“。</p><p>按照以下步骤修改 feedAndMultiply：</p><ol><li>”捕猎“行为会触发僵尸的”冷却周期“</li><li>僵尸在这段”冷却周期“结束前不可再捕猎小猫</li></ol><p>这将限制僵尸，防止其无限制地捕猎小猫或者整天不停地繁殖。将来，当我们增加战斗功能时，我们同样用”冷却周期“限制僵尸之间打斗的频率。</p><p>首先，我们要定义一些辅助函数，设置并检查僵尸的 readyTime。<br><strong>将结构体作为参数传入</strong><br>由于结构体的存储指针可以以参数的方式传递给一个 private 或 internal 的函数，因此结构体可以在多个函数之间相互传递。</p><p>遵循这样的语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal &#123;</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">  _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">    return (_zombie.readyTime &lt;= now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑦公有函数和安全性"><a href="#⑦公有函数和安全性" class="headerlink" title="⑦公有函数和安全性"></a>⑦公有函数和安全性</h4><p>现在来修改 feedAndMultiply ，实现冷却周期。</p><p>回顾一下这个函数，前一课上我们将其可见性设置为public。你必须仔细地检查所有声明为 public 和 external的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 onlyOwner 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p><p>检查完这个函数，用户就可以直接调用这个它，并传入他们所希望的 _targetDna 或 species 。</p><p>仔细观察，这个函数只需被 feedOnKitty() 调用，因此，想要防止漏洞，最简单的方法就是设其可见性为 internal。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 使这个函数的可见性为 internal</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string species) internal &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));// 2. 在这里为 `_isReady` 增加一个检查</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);// 3. 调用 `_triggerCooldown`</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑧进一步了解函数修饰符"><a href="#⑧进一步了解函数修饰符" class="headerlink" title="⑧进一步了解函数修饰符"></a>⑧进一步了解函数修饰符</h4><p><strong>带参数的函数修饰符</strong><br>之前我们已经读过一个简单的函数修饰符了：onlyOwner。函数修饰符也可以带参数。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) &#123;</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) &#123;</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧， olderThan 修饰符可以像函数一样接收参数，是“宿主”函数 driveCar 把参数传递给它的修饰符的。</p><p>来，我们自己生产一个修饰符，通过传入的level参数来限制僵尸使用某些特殊功能。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑨僵尸修饰符"><a href="#⑨僵尸修饰符" class="headerlink" title="⑨僵尸修饰符"></a>⑨僵尸修饰符</h4><p>现在让我们设计一些使用 aboveLevel 修饰符的函数。</p><p>作为游戏，您得有一些措施激励玩家们去升级他们的僵尸：</p><ul><li>2级以上的僵尸，玩家可给他们改名。</li><li>20级以上的僵尸，玩家能给他们定制的 DNA。</li></ul><p>是实现这些功能的时候了。以下是上一课的示例代码，供参考：（第八节课的代码）<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑩利用-‘View’-函数节省-Gas"><a href="#⑩利用-‘View’-函数节省-Gas" class="headerlink" title="⑩利用 ‘View’ 函数节省 Gas"></a>⑩利用 ‘View’ 函数节省 Gas</h4><p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 getZombiesByOwner。</p><p>实现这个功能只需从区块链中读取数据，所以它可以是一个 view 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p><p><strong>“view” 函数不花 “gas”</strong><br>当玩家从外部调用一个view函数，是不需要支付一分 gas 的。</p><p>这是因为 view 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 view 标记一个函数，意味着告诉 web3.js，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p><p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“external view 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p><blockquote><p>注意：如果一个 view 函数在另一个函数的内部被调用，而调用函数与 view 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 view 的函数只有在外部调用时才是免费的。<br>实战演习：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑪存储非常昂贵"><a href="#⑪存储非常昂贵" class="headerlink" title="⑪存储非常昂贵"></a>⑪存储非常昂贵</h4><p>Solidity 使用storage(存储)是相当昂贵的，”写入“操作尤其贵。</p><p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p><p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 memory(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p><p>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了external view的函数，遍历比 storage 要便宜太多，因为 view 函数不会产生任何花销。</p><p>我们将在下一章讨论for循环，现在我们来看一下看如何如何在内存中声明数组。</p><p><strong>在内存中声明数组</strong><br>在数组后面加上 memory关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 storage 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在view里用，完全不用花钱。</p><p>以下是申明一个内存数组的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getArray() external pure returns(uint[]) &#123;</span><br><span class="line">  // 初始化一个长度为3的内存数组</span><br><span class="line">  uint[] memory values = new uint[](3);</span><br><span class="line">  // 赋值</span><br><span class="line">  values.push(1);</span><br><span class="line">  values.push(2);</span><br><span class="line">  values.push(3);</span><br><span class="line">  // 返回数组</span><br><span class="line">  return values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 for 循环结合的做法。</p><blockquote><p>注意：内存数组 必须 用长度参数（在本例中为3）创建。目前不支持 array.push()之类的方法调整数组大小，在未来的版本可能会支持长度修改。<br>实战演习：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑫For循环"><a href="#⑫For循环" class="headerlink" title="⑫For循环"></a>⑫For循环</h4><p>在之前的章节中，我们提到过，函数中使用的数组是运行时在内存中通过 for 循环实时构建，而不是预先建立在存储中的。</p><p>为什么要这样做呢？</p><p>为了实现 getZombiesByOwner 函数，一种“无脑式”的解决方案是在 ZombieFactory 中存入”主人“和”僵尸军团“的映射。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; uint[]) public ownerToZombies</span><br></pre></td></tr></table></figure><p>然后我们每次创建新僵尸时，执行 ownerToZombies [owner] .push（zombieId） 将其添加到主人的僵尸数组中。而 getZombiesByOwner 函数也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns (uint[]) &#123;</span><br><span class="line">  return ownerToZombies[_owner];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个做法有问题</strong><br>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p><p>这个“换主”函数要做到：</p><p>1.将僵尸push到新主人的 ownerToZombies 数组中， 2.从旧主的 ownerToZombies 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p><p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p><p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p><blockquote><p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p></blockquote><p>由于从外部调用一个 view 函数是免费的，我们也可以在 getZombiesByOwner 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 transfer 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p><p><strong>使用 for 循环</strong><br>for循环的语法在 Solidity 和 JavaScript 中类似。</p><p>来看一个创建偶数数组的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) &#123;</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return evens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数将返回一个形为 [2,4,6,8,10] 的数组。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑬放在一起"><a href="#⑬放在一起" class="headerlink" title="⑬放在一起"></a>⑬放在一起</h4><p><strong>让我们回顾一下：</strong></p><ul><li>添加了一种新方法来修改CryptoKitties合约</li><li>学会使用 onlyOwner 进行调用权限限制</li><li>了解了 gas 和 gas 的优化</li><li>为僵尸添加了 “级别” 和 “冷却周期”属性</li><li>当僵尸达到一定级别时，允许修改僵尸的名字和 DNA</li><li>最后，定义了一个函数，用以返回某个玩家的僵尸军团</li></ul><h4 id="⑭第三课完成"><a href="#⑭第三课完成" class="headerlink" title="⑭第三课完成"></a>⑭第三课完成</h4><p>截至第三课完成，所有代码如下：<br>zombiehelper.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zombiefeeding.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">      return (_zombie.readyTime &lt;= now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zombiefactory.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    uint cooldownTime = 1 days;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">    mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        randDna = randDna - randDna % 100;</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ownable.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="心得-①-②-③-④-⑤-⑥-⑦-⑧-⑨-⑩-⑪-⑫-⑬-⑭-⑮-⑯-⑰-⑱-⑲-⑳"><a href="#心得-①-②-③-④-⑤-⑥-⑦-⑧-⑨-⑩-⑪-⑫-⑬-⑭-⑮-⑯-⑰-⑱-⑲-⑳" class="headerlink" title="心得 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳"></a>心得 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳</h3><h4 id="①第二课-第7节Storage与Memory"><a href="#①第二课-第7节Storage与Memory" class="headerlink" title="①第二课 第7节Storage与Memory"></a>①第二课 第7节Storage与Memory</h4><p>实战演习代码的第三行<br>require(msg.sender &#x3D;&#x3D; zombieToOwner[_zombieId]);<br>&#x3D;&#x3D; 后面为什么是 zombieToOwner[_zombieId]);<br>而不是 _zombieId</p><h4 id="②第二课-第3节Msg-sender"><a href="#②第二课-第3节Msg-sender" class="headerlink" title="②第二课 第3节Msg.sender"></a>②第二课 第3节Msg.sender</h4><p>实战演习中<br>    zombieToOwner[id] &#x3D; msg.sender;<br>    ownerZombieCount[msg.sender]++;<br>的这两句代码无法理解</p><h4 id="③第一课-第8节"><a href="#③第一课-第8节" class="headerlink" title="③第一课 第8节"></a>③第一课 第8节</h4><p>游戏第一课的第八小节的实战演习中<br>误把 zombies.push(Zombie(_name, _dna)); 写成了zombies.push(Zombie(name, dna));</p><h4 id="④第一课-第9节"><a href="#④第一课-第9节" class="headerlink" title="④第一课 第9节"></a>④第一课 第9节</h4><p>游戏第一课的第九小节的实战演习中<br>误把 function createZombie(string _name, uint _dna) private {; 写成了function _createZombie(string _name, uint <em>dna) private {;</em></p><h4 id="⑤第一课-第11节"><a href="#⑤第一课-第11节" class="headerlink" title="⑤第一课 第11节"></a>⑤第一课 第11节</h4><p>游戏第一课的第十一小节的实战演习中 把uint rand &#x3D; uint(keccak256(_str));<br>写成了uint rand &#x3D; (uint)keccak256(_str);</p><h4 id="⑥第二课第6节"><a href="#⑥第二课第6节" class="headerlink" title="⑥第二课第6节"></a>⑥第二课第6节</h4><p>‘_isReady’函数里为什么是’return (_zombie.readyTime &lt;&#x3D; now);’<br>而不是’require(_zombie.readyTime &lt;&#x3D; now);’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语言学习</title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="RUNOOB-Markdown-Test学习"><a href="#RUNOOB-Markdown-Test学习" class="headerlink" title="RUNOOB Markdown Test学习"></a>RUNOOB Markdown Test学习</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><h1 id="标题格式："><a href="#标题格式：" class="headerlink" title="标题格式："></a>标题格式：</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h1 id="字体格式："><a href="#字体格式：" class="headerlink" title="字体格式："></a>字体格式：</h1><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h1 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h1><hr><hr><hr><hr><hr><h1 id="删除线："><a href="#删除线：" class="headerlink" title="删除线："></a>删除线：</h1><p>RUNOOB.COM<br>GOOGLE.COM<br><del>BAIDU.COM</del></p><h1 id="下划线："><a href="#下划线：" class="headerlink" title="下划线："></a>下划线：</h1><p><u>带下划线文本</u></p><h1 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h1><p>脚注格式：[^要注明的文本]<br>创建脚注格式类似这样 [^创建]。</p><p>[^创建]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h1 id="无序列表（三种形式都可以）："><a href="#无序列表（三种形式都可以）：" class="headerlink" title="无序列表（三种形式都可以）："></a>无序列表（三种形式都可以）：</h1><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h1 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h1><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h1 id="列表嵌套（需要在子列表的前面加四个空格）："><a href="#列表嵌套（需要在子列表的前面加四个空格）：" class="headerlink" title="列表嵌套（需要在子列表的前面加四个空格）："></a>列表嵌套（需要在子列表的前面加四个空格）：</h1><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="区块（-gt-后面需要加一个空格）："><a href="#区块（-gt-后面需要加一个空格）：" class="headerlink" title="区块（&gt;后面需要加一个空格）："></a>区块（&gt;后面需要加一个空格）：</h1><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><h2 id="区块嵌套："><a href="#区块嵌套：" class="headerlink" title="区块嵌套："></a>区块嵌套：</h2><blockquote><p>最外层</p><blockquote><p>第一层嵌套<br>111</p><blockquote><p>第二层嵌套<br>222</p></blockquote></blockquote></blockquote><h2 id="区块中使用列表："><a href="#区块中使用列表：" class="headerlink" title="区块中使用列表："></a>区块中使用列表：</h2><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="列表中使用区块："><a href="#列表中使用区块：" class="headerlink" title="列表中使用区块："></a>列表中使用区块：</h2><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p><code>printf()</code> 函数<br><code>System.out.println()</code> 函数</p><h2 id="代码区块-代码区块使用-4-个空格或者一个制表符（Tab-键）。-："><a href="#代码区块-代码区块使用-4-个空格或者一个制表符（Tab-键）。-：" class="headerlink" title="代码区块(代码区块使用 4 个空格或者一个制表符（Tab 键）。)："></a>代码区块(代码区块使用 4 个空格或者一个制表符（Tab 键）。)：</h2><pre><code>System.out.println()public classpublic static void main</code></pre><h2 id="你也可以用-96-96-96-包裹一段代码，并指定一种语言（也可以不指定）："><a href="#你也可以用-96-96-96-包裹一段代码，并指定一种语言（也可以不指定）：" class="headerlink" title="你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）："></a>你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h1><p>第一种形式：<a href="https://www.runoob.com/">https://www.runoob.com</a><br>第二种形式：这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><h2 id="高级链接（感觉没太大用处）："><a href="#高级链接（感觉没太大用处）：" class="headerlink" title="高级链接（感觉没太大用处）："></a>高级链接（感觉没太大用处）：</h2><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>语法格式：<br><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p><p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"></p><ol><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的<br>‘title’ 属性的文字。</li></ol><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"><br>也可以像网址那样对图片网址使用变量:</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><img src="http://static.runoob.com/images/runoob-logo.png" width="50%"><h1 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>语法格式如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式：我们可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格11111</td><td align="right">单元格11111</td><td align="center">单元格11111111111</td></tr><tr><td align="left">单元格222222</td><td align="right">单元格222222222</td><td align="center">单元格22</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
