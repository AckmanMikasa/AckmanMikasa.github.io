<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>僵尸游戏第一课</title>
      <link href="/post/4c73e1c2.html"/>
      <url>/post/4c73e1c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="pdf文件"><a href="#pdf文件" class="headerlink" title="pdf文件"></a>pdf文件</h1><p><a href="https://formikasaever.github.io/pdf/%E4%B8%89%E5%8F%B6%E8%8D%89%E5%AE%9E%E9%AA%8C%E5%AE%A4%E2%80%9C%E6%9C%9F%E6%9C%AB%E4%BB%BB%E5%8A%A1%E2%80%9D%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%89.pdf">https://formikasaever.github.io/pdf/%E4%B8%89%E5%8F%B6%E8%8D%89%E5%AE%9E%E9%AA%8C%E5%AE%A4%E2%80%9C%E6%9C%9F%E6%9C%AB%E4%BB%BB%E5%8A%A1%E2%80%9D%E4%BB%BB%E5%8A%A1%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%89.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第六课</title>
      <link href="/post/8cc639b3.html"/>
      <url>/post/8cc639b3.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”任务一-第六课"><a href="#三叶草实验室“期末任务”任务一-第六课" class="headerlink" title="三叶草实验室“期末任务”任务一(第六课)"></a>三叶草实验室“期末任务”任务一(第六课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="6-应用前端和Web3-js"><a href="#6-应用前端和Web3-js" class="headerlink" title="6.应用前端和Web3.js"></a>6.应用前端和Web3.js</h3><h4 id="①介绍-Web3-js"><a href="#①介绍-Web3-js" class="headerlink" title="①介绍 Web3.js"></a>①介绍 Web3.js</h4><p>完成第五课以后，我们的僵尸 DApp 的 Solidity 合约部分就完成了。现在我们来做一个基本的网页好让你的用户能玩它。 要做到这一点，我们将使用以太坊基金发布的 JavaScript 库 —— <code>Web3.js.</code></p><p><strong>什么是 Web3.js?</strong></p><p>还记得么？以太坊网络是由节点组成的，每一个节点都包含了区块链的一份拷贝。当你想要调用一份智能合约的一个方法，你需要从其中一个节点中查找并告诉它:</p><ol><li>智能合约的地址</li><li>你想调用的方法，以及</li><li>你想传入那个方法的参数</li></ol><p>以太坊节点只能识别一种叫做 <code>JSON-RPC</code> 的语言。这种语言直接读起来并不好懂。当你你想调用一个合约的方法的时候，需要发送的查询语句将会是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 哈……祝你写所有这样的函数调用的时候都一次通过</span><br><span class="line">// 往右边拉…… ==&gt;</span><br><span class="line">&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;:[&#123;&quot;from&quot;:&quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;,&quot;to&quot;:&quot;0xd46e8dd67c5d32be8058bb8eb970870f07244567&quot;,&quot;gas&quot;:&quot;0x76c0&quot;,&quot;gasPrice&quot;:&quot;0x9184e72a000&quot;,&quot;value&quot;:&quot;0x9184e72a&quot;,&quot;data&quot;:&quot;0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675&quot;&#125;],&quot;id&quot;:1&#125;</span><br></pre></td></tr></table></figure><p>幸运的是 Web3.js 把这些令人讨厌的查询语句都隐藏起来了， 所以你只需要与方便易懂的 JavaScript 界面进行交互即可。</p><p>你不需要构建上面的查询语句，在你的代码中调用一个函数看起来将是这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CryptoZombies.methods.createRandomZombie(&quot;Vitalik Nakamoto 🤔&quot;)</span><br><span class="line">  .send(&#123; from: &quot;0xb60e8dd61c5d32be8058bb8eb970870f07233155&quot;, gas: &quot;3000000&quot; &#125;)</span><br></pre></td></tr></table></figure><p>我们将在接下来的几章详细解释这些语句，不过首先我们来把 Web3.js 环境搭建起来。</p><p><strong>准备好了么？</strong><br>取决于你的项目工作流程和你的爱好，你可以用一些常用工具把 Web3.js 添加进来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用 NPM</span><br><span class="line">npm install web3</span><br><span class="line"></span><br><span class="line">// 用 Yarn</span><br><span class="line">yarn add web3</span><br><span class="line"></span><br><span class="line">// 用 Bower</span><br><span class="line">bower install web3</span><br><span class="line"></span><br><span class="line">// ...或者其他。</span><br></pre></td></tr></table></figure><p>甚至，你可以从 <code>github</code> 直接下载压缩后的 <code>.js </code>文件 然后包含到你的项目文件中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;web3.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>因为我们不想让你花太多在项目环境搭建上，在本教程中我们将使用上面的 <code>script</code> 标签来将 Web3.js 引入。</p><p>实战演习：<br><strong>index.html:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;CryptoZombies front-end&lt;/title&gt;</span><br><span class="line">    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot; src=&quot;web3.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="②Web3-提供者"><a href="#②Web3-提供者" class="headerlink" title="②Web3 提供者"></a>②Web3 提供者</h4><hr><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第五课</title>
      <link href="/post/e9c8726a.html"/>
      <url>/post/e9c8726a.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”总结（续）-第五课"><a href="#三叶草实验室“期末任务”总结（续）-第五课" class="headerlink" title="三叶草实验室“期末任务”总结（续）(第五课)"></a>三叶草实验室“期末任务”总结（续）(第五课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="5-ERC721标准和加密收藏品"><a href="#5-ERC721标准和加密收藏品" class="headerlink" title="5.ERC721标准和加密收藏品"></a>5.ERC721标准和加密收藏品</h3><h4 id="①以太坊上的代币"><a href="#①以太坊上的代币" class="headerlink" title="①以太坊上的代币"></a>①以太坊上的代币</h4><p>让我们来聊聊 <em>代币</em>.</p><p>如果你对以太坊的世界有一些了解，你很可能听过人们聊到代币——尤其是 ERC20 代币.</p><p>一个 <em>代币</em> 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 <code>transfer(address _to, uint256 _value)</code> 和 <code>balanceOf(address _owner)</code>.</p><p>在智能合约内部，通常有一个映射，<code>mapping(address =&gt; uint256) balances</code>，用于追踪每个地址还有多少余额。</p><p>所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数。</p><p><strong>它为什么重要呢？</strong><br>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。</p><p>这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。</p><p>其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。</p><p>交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。</p><p><strong>其他代币标准</strong><br>对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。</p><p>首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。</p><p>其次，并不是所有僵尸都是平等的。 你的2级僵尸”Steve”完全不能等同于我732级的僵尸”H4XF13LD MORRIS 💯💯😎💯💯”。（你差得远呢，Steve）。</p><p>有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为ERC721 代币.</p><p>ERC721 代币是不能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p><blockquote><p>请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。</p></blockquote><p>实战演习:<br>zombieownership.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombieattack.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieOwnership is ZombieAttack &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②ERC721-标准-多重继承"><a href="#②ERC721-标准-多重继承" class="headerlink" title="②ERC721 标准, 多重继承"></a>②ERC721 标准, 多重继承</h4><p>让我们来看一看 ERC721 标准：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们需要实现的方法列表，我们将在接下来的章节中逐个学习。</p><p>虽然看起来很多，但不要被吓到了！我们在这里就是准备带着你一步一步了解它们的。</p><blockquote><p>注意： ERC721目前是一个 草稿，还没有正式商定的实现。在本教程中，我们使用的是 OpenZeppelin 库中的当前版本，但在未来正式发布之前它可能会有更改。 所以把这 一个 可能的实现当作考虑，但不要把它作为 ERC721 代币的官方标准。</p></blockquote><p><strong>实现一个代币合约</strong><br>在实现一个代币合约的时候，我们首先要做的是将接口复制到它自己的 Solidity 文件并导入它，<code>import &quot;./erc721.sol&quot;;</code>。 接着，让我们的合约继承它，然后我们用一个函数定义来重写每个方法。</p><p>但等一下—— <code>ZombieOwnership</code>已经继承自 <code>ZombieAttack</code>了 —— 它如何能够也继承于 <code>ERC721</code>呢？</p><p>幸运的是在Solidity，你的合约可以继承自多个合约，参考如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SatoshiNakamoto is NickSzabo, HalFinney &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见，当使用多重继承的时候，你只需要用逗号 , 来隔开几个你想要继承的合约。在上面的例子中，我们的合约继承自 <code>NickSzabo</code> 和 <code>HalFinney</code>。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombieattack.sol&quot;;</span><br><span class="line">import &quot;./erc721.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③balanceOf-和-ownerOf"><a href="#③balanceOf-和-ownerOf" class="headerlink" title="③balanceOf 和 ownerOf"></a>③balanceOf 和 ownerOf</h4><p>在本章节，我们将实现头两个方法： balanceOf 和 ownerOf。</p><p><strong>balanceOf</strong><br><code>function balanceOf(address _owner) public view returns (uint256 _balance);</code><br>这个函数只需要一个传入 address 参数，然后返回这个 address 拥有多少代币。</p><p>在我们的例子中，我们的“代币”是僵尸。你还记得在我们 DApp 的哪里存储了一个主人拥有多少只僵尸吗？</p><p><strong>ownerOf</strong></p><p><code>function ownerOf(uint256 _tokenId) public view returns (address _owner);</code><br>这个函数需要传入一个代币 ID 作为参数 (我们的情况就是一个僵尸 ID)，然后返回该代币拥有者的 address。</p><p>同样的，因为在我们的 DApp 里已经有一个 mapping (映射) 存储了这个信息，所以对我们来说这个实现非常直接清晰。我们可以只用一行 return 语句来实现这个函数。</p><blockquote><p>注意：要记得， uint256 等同于uint。我们从课程的开始一直在代码中使用 uint，但从现在开始我们将在这里用 uint256，因为我们直接从规范中复制粘贴。</p></blockquote><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function balanceOf(address _owner) public view returns (uint256 _balance) &#123;</span><br><span class="line">  return ownerZombieCount[_owner];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ownerOf(uint256 _tokenId) public view returns (address _owner) &#123;</span><br><span class="line">  return zombieToOwner[_tokenId];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④重构"><a href="#④重构" class="headerlink" title="④重构"></a>④重构</h4><p>我们刚刚的代码中其实有个错误，以至于其根本无法通过编译，你发现了没？</p><p>在前一个章节我们定义了一个叫 ownerOf 的函数。但如果你还记得第4课的内容，我们同样在zombiefeeding.sol 里以 ownerOf 命名创建了一个 modifier（修饰符）。</p><p>如果你尝试编译这段代码，编译器会给你一个错误说你不能有相同名称的修饰符和函数。</p><p>所以我们应该把在 ZombieOwnership 里的函数名称改成别的吗？</p><p>不，我们不能那样做！！！要记得，我们正在用 ERC721 代币标准，意味着其他合约将期望我们的合约以这些确切的名称来定义函数。这就是这些标准实用的原因——如果另一个合约知道我们的合约符合 ERC721 标准，它可以直接与我们交互，而无需了解任何关于我们内部如何实现的细节。</p><p>所以，那意味着我们将必须重构我们第4课中的代码，将 modifier 的名称换成别的。</p><p>实战演习：<br>我们回到了 zombiefeeding.sol 。我们将把 modifier 的名称从 ownerOf 改成 onlyOwnerOf。</p><ol><li><p>把修饰符定义中的名称改成 onlyOwnerOf</p></li><li><p>往下滑到使用此修饰符的函数 feedAndMultiply 。我们也需要改这里的名称。</p></li></ol><blockquote><p>注意：我们在 zombiehelper.sol 和 zombieattack.sol 里也使用了这个修饰符，但为了不在这节课的重构里花太多时间，我们已经将那些文件里的修饰符名称为你改好了。</p></blockquote><h4 id="⑤ERC721-转移标准"><a href="#⑤ERC721-转移标准" class="headerlink" title="⑤ERC721: 转移标准"></a>⑤ERC721: 转移标准</h4><p>现在我们将通过学习把所有权从一个人转移给另一个人来继续我们的 ERC721 规范的实现。</p><p>注意 ERC721 规范有两种不同的方法来转移代币：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line"></span><br><span class="line">function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">function takeOwnership(uint256 _tokenId) public;</span><br></pre></td></tr></table></figure><ol><li><p>第一种方法是代币的拥有者调用transfer 方法，传入他想转移到的 address 和他想转移的代币的 _tokenId。</p></li><li><p>第二种方法是代币拥有者首先调用 approve，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 mapping (uint256 &#x3D;&gt; address) 里。然后，当有人调用 takeOwnership 时，合约会检查 msg.sender 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。</p></li></ol><p>你注意到了吗，transfer 和 takeOwnership 都将包含相同的转移逻辑，只是以相反的顺序。 （一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它）。</p><p>所以我们把这个逻辑抽象成它自己的私有函数 _transfer，然后由这两个函数来调用它。 这样我们就不用写重复的代码了。</p><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address _from, address _to, uint256 _tokenId) private &#123;</span><br><span class="line">    ownerZombieCount[_to]++;</span><br><span class="line">    ownerZombieCount[_from]--;</span><br><span class="line">    zombieToOwner[_tokenId] = _to;</span><br><span class="line">    Transfer(_from, _to, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥ERC721-转移-续"><a href="#⑥ERC721-转移-续" class="headerlink" title="⑥ERC721: 转移-续"></a>⑥ERC721: 转移-续</h4><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑦ERC721-批准"><a href="#⑦ERC721-批准" class="headerlink" title="⑦ERC721: 批准"></a>⑦ERC721: 批准</h4><p>现在，让我们来实现 approve。</p><p>记住，使用 approve 或者 takeOwnership 的时候，转移有2个步骤：</p><ol><li><p>你，作为所有者，用新主人的 address 和你希望他获取的 _tokenId 来调用 approve</p></li><li><p>新主人用 _tokenId 来调用 takeOwnership，合约会检查确保他获得了批准，然后把代币转移给他。</p></li></ol><p>因为这发生在2个函数的调用中，所以在函数调用之间，我们需要一个数据结构来存储什么人被批准获取什么。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (uint =&gt; address) zombieApprovals;</span><br><span class="line"></span><br><span class="line">function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    zombieApprovals[_tokenId] = _to;</span><br><span class="line">    Approval(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑧ERC721-takeOwnership"><a href="#⑧ERC721-takeOwnership" class="headerlink" title="⑧ERC721: takeOwnership"></a>⑧ERC721: takeOwnership</h4><p>最后一个函数 takeOwnership， 应该只是简单地检查以确保 msg.sender 已经被批准来提取这个代币或者僵尸。若确认，就调用 _transfer；</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function takeOwnership(uint256 _tokenId) public &#123;</span><br><span class="line">    require(zombieApprovals[_tokenId] == msg.sender);</span><br><span class="line">    address owner = ownerOf(_tokenId);</span><br><span class="line">    _transfer(owner, msg.sender, _tokenId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑨预防溢出"><a href="#⑨预防溢出" class="headerlink" title="⑨预防溢出"></a>⑨预防溢出</h4><p>我们完成了 ERC721 的实现。</p><p>不过要记住那只是最简单的实现。还有很多的特性我们也许想加入到我们的实现中来，比如一些额外的检查，来确保用户不会不小心把他们的僵尸转移给0 地址（这被称作 “烧币”, 基本上就是把代币转移到一个谁也没有私钥的地址，让这个代币永远也无法恢复）。 或者在 DApp 中加入一些基本的拍卖逻辑。（你能想出一些实现的方法么？）</p><p>但是为了让我们的课程不至于离题太远，所以我们只专注于一些基础实现。如果你想学习一些更深层次的实现，可以在这个教程结束后，去看看 OpenZeppelin 的 ERC721 合约。</p><p><strong>合约安全增强: 溢出和下溢</strong><br>我们将来学习你在编写智能合约的时候需要注意的一个主要的安全特性：防止溢出和下溢。</p><p>什么是 <em>溢出</em> (overflow)?</p><p>假设我们有一个 uint8, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 11111111 (或者说十进制的 2^8 - 1 &#x3D; 255).</p><p>来看看下面的代码。最后 number 将会是什么值？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 number = 255;</span><br><span class="line">number++;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是 number 出乎意料地等于 0了。 (如果你给二进制 11111111 加1, 它将被重置为 00000000，就像钟表从 23:59 走向 00:00)。</p><p>下溢(underflow)也类似，如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。</p><p>虽然我们在这里不使用 uint8，而且每次给一个 uint256 加 1 也不太可能溢出 (2^256 真的是一个很大的数了)，在我们的合约中添加一些保护机制依然是非常有必要的，以防我们的 DApp 以后出现什么异常情况。</p><p><strong>使用 SafeMath</strong><br>为了防止这些情况，OpenZeppelin 建立了一个叫做 SafeMath 的 <em>库</em>(library)，默认情况下可以防止这些问题。</p><p>不过在我们使用之前…… 什么叫做库?</p><p>一个_库_ 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。</p><p>比如，使用 SafeMath 库的时候，我们将使用 using SafeMath for uint256 这样的语法。 SafeMath 库有四个方法 — add， sub， mul， 以及 div。现在我们可以这样来让 uint256 调用这些方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = 5;</span><br><span class="line">uint256 b = a.add(3); // 5 + 3 = 8</span><br><span class="line">uint256 c = a.mul(2); // 5 * 2 = 10</span><br></pre></td></tr></table></figure><p>我们将在下一章来学习这些方法，不过现在我们先将 SafeMath 库添加进我们的合约。</p><p>实战演习：</p><ol><li>将 safemath.sol 引入到 zombiefactory.sol.</li><li>添加定义： using SafeMath for uint256;.</li></ol><h4 id="⑩SafeMath第二部分"><a href="#⑩SafeMath第二部分" class="headerlink" title="⑩SafeMath第二部分"></a>⑩SafeMath第二部分</h4><p>来看看 SafeMath 的部分代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们有了 library 关键字 — 库和 合约很相似，但是又有一些不同。 就我们的目的而言，库允许我们使用 using 关键字，它可以自动把库的所有方法添加给一个数据类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint;</span><br><span class="line">// 这下我们可以为任何 uint 调用这些方法了</span><br><span class="line">uint test = 2;</span><br><span class="line">test = test.mul(3); // test 等于 6 了</span><br><span class="line">test = test.add(5); // test 等于 11 了</span><br></pre></td></tr></table></figure><p>注意 mul 和 add 其实都需要两个参数。 在我们声明了 using SafeMath for uint 后，我们用来调用这些方法的 uint 就自动被作为第一个参数传递进去了(在此例中就是 test)</p><p>我们来看看 add 的源代码看 SafeMath 做了什么:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上 add 只是像 + 一样对两个 uint 相加， 但是它用一个 assert 语句来确保结果大于 a。这样就防止了溢出。</p><p>assert 和 require 相似，若结果为否它就会抛出错误。 assert 和 require 区别在于，require 若失败则会返还给用户剩下的 gas， assert 则不会。所以大部分情况下，你写代码的时候会比较喜欢 require，assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。</p><p>所以简而言之， SafeMath 的 add， sub， mul， 和 div 方法只做简单的四则运算，然后在发生溢出或下溢的时候抛出错误。</p><p><strong>在我们的代码里使用 SafeMath。</strong><br>为了防止溢出和下溢，我们可以在我们的代码里找 +， -， *， 或 &#x2F;，然后替换为 add, sub, mul, div.</p><p>比如，与其这样做:<code>myUint++;</code><br>我们这样做:<code>myUint = myUint.add(1);</code></p><p>实战演习：<br>    &#x2F;&#x2F; 1. 替换成 SafeMath 的 <code>add</code><br>    ownerZombieCount[_to]++;<br>    &#x2F;&#x2F; 2. 替换成 SafeMath 的 <code>sub</code><br>    ownerZombieCount[_from]–;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ownerZombieCount[_to] = ownerZombieCount[_to].add(1);</span><br><span class="line">ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);</span><br></pre></td></tr></table></figure><h4 id="⑪SafeMath-第三部分"><a href="#⑪SafeMath-第三部分" class="headerlink" title="⑪SafeMath 第三部分"></a>⑪SafeMath 第三部分</h4><p>太好了，这下我们的 ERC721 实现不会有溢出或者下溢了。</p><p>回头看看我们在之前课程写的代码，还有其他几个地方也有可能导致溢出或下溢。</p><p>比如， 在 ZombieAttack 里面我们有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myZombie.winCount++;</span><br><span class="line">myZombie.level++;</span><br><span class="line">enemyZombie.lossCount++;</span><br></pre></td></tr></table></figure><p>我们同样应该在这些地方防止溢出。（通常情况下，总是使用 SafeMath 而不是普通数学运算是个好主意，也许在以后 Solidity 的新版本里这点会被默认实现，但是现在我们得自己在代码里实现这些额外的安全措施）。</p><p>不过我们遇到个小问题 — winCount 和 lossCount 是 uint16， 而 level 是 uint32。 所以如果我们用这些作为参数传入 SafeMath 的 add 方法。 它实际上并不会防止溢出，因为它会把这些变量都转换成 uint256:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">  uint256 c = a + b;</span><br><span class="line">  assert(c &gt;= a);</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果我们在`uint8` 上调用 `.add`。它将会被转换成 `uint256`.</span><br><span class="line">// 所以它不会在 2^8 时溢出，因为 256 是一个有效的 `uint256`.</span><br></pre></td></tr></table></figure><p>这就意味着，我们需要再实现两个库来防止 uint16 和 uint32 溢出或下溢。我们可以将其命名为 SafeMath16 和 SafeMath32。</p><p>代码将和 SafeMath 完全相同，除了所有的 uint256 实例都将被替换成 uint32 或 uint16。</p><p>我们已经将这些代码帮你写好了，打开 safemath.sol 合约看看代码吧。</p><p>现在我们需要在 ZombieFactory 里使用它们。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint256;</span><br><span class="line">using SafeMath32 for uint32;</span><br><span class="line">using SafeMath16 for uint16;</span><br></pre></td></tr></table></figure><h4 id="⑫SafeMath-第4部分"><a href="#⑫SafeMath-第4部分" class="headerlink" title="⑫SafeMath 第4部分"></a>⑫SafeMath 第4部分</h4><p>真棒，现在我们已经为我们的 DApp 里面用到的 uint 数据类型都实现了 SafeMath 了。</p><p>让我们把 ZombieAttack 里所有潜在的问题都修复了吧。 （其实在 ZombieHelper 里也有一处 zombies[_zombieId].level++; 需要修复，不过我们已经帮你做好了，这样我们就不用再来一章了 😉）。</p><h4 id="⑬注释"><a href="#⑬注释" class="headerlink" title="⑬注释"></a>⑬注释</h4><p>僵尸游戏的 Solidity 代码终于完成啦。</p><p>在以后的课程中，我们将学习如何将游戏部署到以太坊，以及如何和 Web3.js 交互。</p><p>不过在你离开第五课之前，我们来谈谈如何 给你的代码添加注释.</p><p><strong>注释语法</strong><br>Solidity 里的注释和 JavaScript 相同。在我们的课程中你已经看到了不少单行注释了：</p><p><code>// 这是一个单行注释，可以理解为给自己或者别人看的笔记</code></p><p>只要在任何地方添加一个 &#x2F;&#x2F; 就意味着你在注释。如此简单所以你应该经常这么做。</p><p>不过我们也知道你的想法：有时候单行注释是不够的。毕竟你生来话痨。</p><p>所以我们有了多行注释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract CryptoZombies &#123;</span><br><span class="line">  /* 这是一个多行注释。我想对所有花时间来尝试这个编程课程的人说声谢谢。</span><br><span class="line">  它是免费的，并将永远免费。但是我们依然倾注了我们的心血来让它变得更好。</span><br><span class="line"></span><br><span class="line">   要知道这依然只是区块链开发的开始而已，虽然我们已经走了很远，</span><br><span class="line">   仍然有很多种方式来让我们的社区变得更好。</span><br><span class="line">   如果我们在哪个地方出了错，欢迎在我们的 github 提交 PR 或者 issue 来帮助我们改进：</span><br><span class="line">    https://github.com/loomnetwork/cryptozombie-lessons</span><br><span class="line"></span><br><span class="line">    或者，如果你有任何的想法、建议甚至仅仅想和我们打声招呼，欢迎来我们的电报群：</span><br><span class="line">     https://t.me/loomnetworkdev</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别是，最好为你合约中每个方法添加注释来解释它的预期行为。这样其他开发者（或者你自己，在6个月以后再回到这个项目中）可以很快地理解你的代码而不需要逐行阅读所有代码。</p><p>Solidity 社区所使用的一个标准是使用一种被称作 natspec 的格式，看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @title 一个简单的基础运算合约</span><br><span class="line">/// @author H4XF13LD MORRIS 💯💯😎💯💯</span><br><span class="line">/// @notice 现在，这个合约只添加一个乘法</span><br><span class="line">contract Math &#123;</span><br><span class="line">  /// @notice 两个数相乘</span><br><span class="line">  /// @param x 第一个 uint</span><br><span class="line">  /// @param y  第二个 uint</span><br><span class="line">  /// @return z  (x * y) 的结果</span><br><span class="line">  /// @dev 现在这个方法不检查溢出</span><br><span class="line">  function multiply(uint x, uint y) returns (uint z) &#123;</span><br><span class="line">    // 这只是个普通的注释，不会被 natspec 解释</span><br><span class="line">    z = x * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@title（标题） 和 @author （作者）很直接了.</li><li>@notice （须知）向 用户 解释这个方法或者合约是做什么的。 @dev （开发者） 是向开发者解释更多的细节。</li><li>@param （参数）和 @return （返回） 用来描述这个方法需要传入什么参数以及返回什么值。</li></ol><p>注意你并不需要每次都用上所有的标签，它们都是可选的。不过最少，写下一个 @dev 注释来解释每个方法是做什么的。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// @title 一个管理转移僵尸所有权的合约</span><br><span class="line">/// @author formikasaever</span><br><span class="line">/// @dev 符合 OpenZeppelin 对 ERC721 标准草案的实现</span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 &#123;</span><br></pre></td></tr></table></figure><h4 id="⑭放在一起"><a href="#⑭放在一起" class="headerlink" title="⑭放在一起"></a>⑭放在一起</h4><p><strong>总结一下</strong><br>这节课里面我们学到了</p><ul><li>代币, ERC721 标准，以及可交易的物件&#x2F;僵尸</li><li>库以及如何使用库</li><li>如何利用 SafeMath 来防止溢出和下溢</li><li>代码注释和 natspec 标准</li></ul><p>这节教程完成了我们游戏的 Solidity 代码（仅针对当下来说，未来的课程我们也许会加入更多进去）。</p><p>在接下来的两节课中，我们将学习如何将游戏部署到以太坊以及和 web3.js 交互 （这样你就能为你的 DApp 打造一个界面了 ）。</p><h4 id="⑮第五课完成"><a href="#⑮第五课完成" class="headerlink" title="⑮第五课完成"></a>⑮第五课完成</h4><p>截至第五课完成，所有代码如下：<br><strong>zombieownership.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombieattack.sol&quot;;</span><br><span class="line">import &quot;./erc721.sol&quot;;</span><br><span class="line">import &quot;./safemath.sol&quot;;</span><br><span class="line"></span><br><span class="line">/// @title 一个管理转移僵尸所有权的合约</span><br><span class="line">/// @author formikasaever</span><br><span class="line">/// @dev 符合 OpenZeppelin 对 ERC721 标准草案的实现</span><br><span class="line">contract ZombieOwnership is ZombieAttack, ERC721 &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  mapping (uint =&gt; address) zombieApprovals;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance) &#123;</span><br><span class="line">    return ownerZombieCount[_owner];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner) &#123;</span><br><span class="line">    return zombieToOwner[_tokenId];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _transfer(address _from, address _to, uint256 _tokenId) private &#123;</span><br><span class="line">    ownerZombieCount[_to] = ownerZombieCount[_to].add(1);</span><br><span class="line">    ownerZombieCount[msg.sender] = ownerZombieCount[msg.sender].sub(1);</span><br><span class="line">    zombieToOwner[_tokenId] = _to;</span><br><span class="line">    Transfer(_from, _to, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    _transfer(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) &#123;</span><br><span class="line">    zombieApprovals[_tokenId] = _to;</span><br><span class="line">    Approval(msg.sender, _to, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function takeOwnership(uint256 _tokenId) public &#123;</span><br><span class="line">    require(zombieApprovals[_tokenId] == msg.sender);</span><br><span class="line">    address owner = ownerOf(_tokenId);</span><br><span class="line">    _transfer(owner, msg.sender, _tokenId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombieattack.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiehelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) &#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiehelper.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner &#123;</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function levelUp(uint _zombieId) external payable &#123;</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefeeding.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwnerOf(uint _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">      return (_zombie.readyTime &lt;= now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal onlyOwnerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefactory.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line">import &quot;./safemath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">  uint dnaDigits = 16;</span><br><span class="line">  uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">  uint cooldownTime = 1 days;</span><br><span class="line"></span><br><span class="line">  struct Zombie &#123;</span><br><span class="line">    string name;</span><br><span class="line">    uint dna;</span><br><span class="line">    uint32 level;</span><br><span class="line">    uint32 readyTime;</span><br><span class="line">    uint16 winCount;</span><br><span class="line">    uint16 lossCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">  mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">  mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">  function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">    uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br><span class="line">    zombieToOwner[id] = msg.sender;</span><br><span class="line">    ownerZombieCount[msg.sender]++;</span><br><span class="line">    NewZombie(id, _name, _dna);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">    uint rand = uint(keccak256(_str));</span><br><span class="line">    return rand % dnaModulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function createRandomZombie(string _name) public &#123;</span><br><span class="line">    require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">    uint randDna = _generateRandomDna(_name);</span><br><span class="line">    randDna = randDna - randDna % 100;</span><br><span class="line">    _createZombie(_name, randDna);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ownable.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>safemath.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that throw on error</span><br><span class="line"> */</span><br><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Multiplies two numbers, throws on overflow.</span><br><span class="line">  */</span><br><span class="line">  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    if (a == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Integer division of two numbers, truncating the quotient.</span><br><span class="line">  */</span><br><span class="line">  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    // assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    // assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).</span><br><span class="line">  */</span><br><span class="line">  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev Adds two numbers, throws on overflow.</span><br><span class="line">  */</span><br><span class="line">  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>erc721.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 _balance);</span><br><span class="line">  function ownerOf(uint256 _tokenId) public view returns (address _owner);</span><br><span class="line">  function transfer(address _to, uint256 _tokenId) public;</span><br><span class="line">  function approve(address _to, uint256 _tokenId) public;</span><br><span class="line">  function takeOwnership(uint256 _tokenId) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第四课</title>
      <link href="/post/8656b72d.html"/>
      <url>/post/8656b72d.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”总结（续）-第四课"><a href="#三叶草实验室“期末任务”总结（续）-第四课" class="headerlink" title="三叶草实验室“期末任务”总结（续）(第四课)"></a>三叶草实验室“期末任务”总结（续）(第四课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="4-僵尸作战系统"><a href="#4-僵尸作战系统" class="headerlink" title="4.僵尸作战系统"></a>4.僵尸作战系统</h3><h4 id="①可支付"><a href="#①可支付" class="headerlink" title="①可支付"></a>①可支付</h4><p>截至目前，我们只接触到很少的 函数修饰符。 要记住所有的东西很难，所以我们来个概览：</p><ol><li><p>我们有决定函数何时和被谁调用的可见性修饰符: private 意味着它只能被合约内部调用； internal 就像 private 但是也能被继承的合约调用； external 只能从合约外部调用；最后 public 可以在任何地方调用，不管是内部还是外部。</p></li><li><p>我们也有状态修饰符， 告诉我们函数如何和区块链交互: view 告诉我们运行这个函数不会更改和保存任何数据； pure 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</p></li><li><p>然后我们有了自定义的 modifiers，例如在第三课学习的: onlyOwner 和 aboveLevel。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</p></li></ol><p>这些修饰符可以同时作用于一个函数定义上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() external view onlyOwner anotherModifier &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><p>在这一章，我们来学习一个新的修饰符 payable.</p><p><strong>payable 修饰符</strong></p><p>payable 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。</p><p>先放一下。当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。</p><p>但是在以太坊中， 因为钱 (<em>以太</em>), 数据 (事务负载)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 并付钱给另外一个合约。</p><p>这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。</p><p><strong>来看个例子</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  function buySomething() external payable &#123;</span><br><span class="line">    // 检查以确定0.001以太发送出去来运行函数:</span><br><span class="line">    require(msg.value == 0.001 ether);</span><br><span class="line">    // 如果为真，一些用来向函数调用者发送数字内容的逻辑</span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，msg.value 是一种可以查看向合约发送了多少以太的方法，另外 ether 是一个內建单元。</p><p>这里发生的事是，一些人会从 web3.js 调用这个函数 (从DApp的前端)， 像这样 :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 假设 `OnlineStore` 在以太坊上指向你的合约:</span><br><span class="line">OnlineStore.buySomething().send(from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001))</span><br></pre></td></tr></table></figure><p>注意这个 value 字段， JavaScript 调用来指定发送多少(0.001)以太。如果把事务想象成一个信封，你发送到函数的参数就是信的内容。 添加一个 value 很像在信封里面放钱 —— 信件内容和钱同时发送给了接收者。</p><blockquote><p>注意： 如果一个函数没标记为payable， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p></blockquote><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">function levelUp(uint _zombieId) external payable &#123;</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②提现"><a href="#②提现" class="headerlink" title="②提现"></a>②提现</h4><p>在你发送以太之后，它将被存储进以合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p><p>你可以写一个函数来从合约中提现以太，类似这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用 Ownable 合约中的 owner 和 onlyOwner，假定它已经被引入了。</p><p>你可以通过 transfer 函数向一个地址发送以太， 然后 this.balance 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， this.balance 将是100以太。</p><p>你可以通过 transfer 向任何以太坊地址付钱。 比如，你可以有一个函数在 msg.sender 超额付款的时候给他们退钱：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint itemFee = 0.001 ether;</span><br><span class="line">msg.sender.transfer(msg.value - itemFee);</span><br></pre></td></tr></table></figure><p>或者在一个有卖家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 seller.transfer(msg.value)。</p><p>有很多例子来展示什么让以太坊编程如此之酷 —— 你可以拥有一个不被任何人控制的去中心化市场。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner &#123;</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="③僵尸战斗"><a href="#③僵尸战斗" class="headerlink" title="③僵尸战斗"></a>③僵尸战斗</h4><p>在我们学习了可支付函数和合约余额之后，是时候为僵尸战斗添加功能了。</p><p>遵循上一章的格式，我们新建一个攻击功能合约，并将代码放进新的文件中，引入上一个合约。<br>实战演习：<br>zombieattack.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiehelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④随机数"><a href="#④随机数" class="headerlink" title="④随机数"></a>④随机数</h4><p><strong>用 keccak256 来制造随机数。</strong><br>Solidity 中最好的随机数生成器是 keccak256 哈希函数.</p><p>我们可以这样来生成一些随机数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 生成一个0到100的随机数:</span><br><span class="line">uint randNonce = 0;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;</span><br></pre></td></tr></table></figure><p>这个方法首先拿到 now 的时间戳、 msg.sender、 以及一个自增数 nonce （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p><p>然后利用 keccak 把输入的值转变为一个哈希值, 再将哈希值转换为 uint, 然后利用 % 100 来取最后两位, 就生成了一个0到100之间随机数了。</p><p><strong>这个方法很容易被不诚实的节点攻击</strong><br>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 transaction 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 block 发布在网络上。</p><p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p><p>这就让我们的随机数函数变得可利用了</p><p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (random &gt;&#x3D; 50 算正面, random &lt; 50 算反面)。</p><p>如果我正运行一个节点，我可以 只对我自己的节点 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p><p><strong>所以我们该如何在以太坊上安全地生成随机数呢</strong><br>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 这个 StackOverflow 上的讨论 来获得一些主意。 一个方法是利用 oracle 来访问以太坊区块链之外的随机数函数。</p><p>当然， 因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p><p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p><p>因为在这个教程中，我们只是在编写一个简单的游戏来做演示，也没有真正的钱在里面，所以我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint randNonce = 0;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) &#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤僵尸对决"><a href="#⑤僵尸对决" class="headerlink" title="⑤僵尸对决"></a>⑤僵尸对决</h4><p>我们的合约已经有了一些随机性的来源，可以用进我们的僵尸战斗中去计算结果。</p><p>我们的僵尸战斗看起来将是这个流程：</p><ul><li>你选择一个自己的僵尸，然后选择一个对手的僵尸去攻击。</li><li>如果你是攻击方，你将有70%的几率获胜，防守方将有30%的几率获胜。</li><li>所有的僵尸（攻守双方）都将有一个 winCount 和一个 lossCount，这两个值都将根据战斗结果增长。</li><li>若攻击方获胜，这个僵尸将升级并产生一个新僵尸。</li><li>如果攻击方失败，除了失败次数将加一外，什么都不会发生。</li><li>无论输赢，当前僵尸的冷却时间都将被激活。</li></ul><p>这有一大堆的逻辑需要处理，我们将把这些步骤分解到接下来的课程中去。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在这里创建 attackVictoryProbability</span><br><span class="line">uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">// 在这里创建新函数</span><br><span class="line">function attack(uint _zombieId, uint _targetId) external &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑥重构通用逻辑"><a href="#⑥重构通用逻辑" class="headerlink" title="⑥重构通用逻辑"></a>⑥重构通用逻辑</h4><p>不管谁调用我们的 attack 函数 —— 我们想确保用户的确拥有他们用来攻击的僵尸。如果你能用其他人的僵尸来攻击将是一个很大的安全问题。</p><p>你能想一下我们如何添加一个检查步骤来看看调用这个函数的人就是他们传入的 _zombieId 的拥有者么？</p><p>想一想，看看你能不能自己找到一些答案。</p><p>花点时间…… 参考我们前面课程的代码来获得灵感。</p><p><strong>答案</strong><br>我们在前面的课程里面已经做过很多次这样的检查了。 在 changeName(), changeDna(), 和 feedAndMultiply()里，我们做过这样的检查：</p><p>require(msg.sender &#x3D;&#x3D; zombieToOwner[_zombieId]);<br>这和我们 attack 函数将要用到的检查逻辑是相同的。 正因我们要多次调用这个检查逻辑，让我们把它移到它自己的 modifier 中来清理代码并避免重复编码。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 在这里创建 modifier</span><br><span class="line">modifier ownerOf(uint _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 2. 在函数定义时增加 modifier :</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) &#123;</span><br><span class="line">    // 3. 移除这一行</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br></pre></td></tr></table></figure><h4 id="⑦更多重构"><a href="#⑦更多重构" class="headerlink" title="⑦更多重构"></a>⑦更多重构</h4><p>在 zombiehelper.sol里有几处地方，需要我们实现我们新的 modifier—— ownerOf。</p><p>实战演习：</p><ol><li><p>修改 changeName() 使其使用 ownerOf</p></li><li><p>修改 changeDna() 使其使用 ownerOf</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在changeName()函数与changeDna()函数的aboveLevel修饰符后面</span><br><span class="line">写上ownerOf(_zombieId)</span><br><span class="line">并删除两个函数中的</span><br><span class="line">require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">这一行代码即可</span><br></pre></td></tr></table></figure></li></ol><h4 id="⑧回到攻击"><a href="#⑧回到攻击" class="headerlink" title="⑧回到攻击"></a>⑧回到攻击</h4><p>重构完成了，回到 zombieattack.sol。</p><p>继续来完善我们的 attack 函数， 现在我们有了 ownerOf 修饰符来用了。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑨僵尸的输赢"><a href="#⑨僵尸的输赢" class="headerlink" title="⑨僵尸的输赢"></a>⑨僵尸的输赢</h4><p>对我们的僵尸游戏来说，我们将要追踪我们的僵尸输赢了多少场。有了这个我们可以在游戏里维护一个 “僵尸排行榜”。</p><p>有多种方法在我们的DApp里面保存一个数值 — 作为一个单独的映射，作为一个“排行榜”结构体，或者保存在 Zombie 结构体内。</p><p>每个方法都有其优缺点，取决于我们打算如何和这些数据打交道。在这个教程中，简单起见我们将这个状态保存在 Zombie 结构体中，将其命名为 winCount 和 lossCount。</p><p>我们跳回 zombiefactory.sol, 将这些属性添加进 Zombie 结构体.</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Zombie &#123;</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">      uint16 winCount;</span><br><span class="line">      uint16 lossCount;</span><br><span class="line">    &#125;</span><br><span class="line">// 2. 在这里修改修改新僵尸的创建:</span><br><span class="line">uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br></pre></td></tr></table></figure><h4 id="⑩僵尸胜利了😄"><a href="#⑩僵尸胜利了😄" class="headerlink" title="⑩僵尸胜利了😄"></a>⑩僵尸胜利了😄</h4><p>有了 winCount 和 lossCount，我们可以根据僵尸哪个僵尸赢了战斗来更新它们了。</p><p>在第六章我们计算出来一个0到100的随机数。现在让我们用那个数来决定那谁赢了战斗，并以此更新我们的状态。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">  myZombie.winCount++;</span><br><span class="line">  myZombie.level++;</span><br><span class="line">  enemyZombie.lossCount++;</span><br><span class="line">  feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑪僵尸失败😞"><a href="#⑪僵尸失败😞" class="headerlink" title="⑪僵尸失败😞"></a>⑪僵尸失败😞</h4><p>我们已经编写了你的僵尸赢了之后会发生什么， 该看看 输了 的时候要怎么做了。</p><p>在我们的游戏中，僵尸输了后并不会降级 —— 只是简单地给 lossCount 加一，并触发冷却，等待一天后才能再次参战。</p><p>要实现这个逻辑，我们需要一个 else 语句。</p><p>else 语句和 JavaScript 以及很多其他语言的 else 语句一样。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (zombieCoins[msg.sender] &gt; 100000000) &#123;</span><br><span class="line">  // 你好有钱!!!</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 我们需要更多的僵尸币...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else&#123;</span><br><span class="line">  myZombie.lossCount++;</span><br><span class="line">  enemyZombie.winCount++;</span><br><span class="line">  _triggerCooldown(myZombie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑫放在一起"><a href="#⑫放在一起" class="headerlink" title="⑫放在一起"></a>⑫放在一起</h4><p><strong>认领你的战利品</strong><br>在赢了战斗之后：</p><ol><li><p>你的僵尸将会升级</p></li><li><p>你僵尸的 winCount 将会增加</p></li><li><p>你将为你的僵尸大军获得一个新的僵尸</p></li></ol><h4 id="⑬Lesson-4-Complete！"><a href="#⑬Lesson-4-Complete！" class="headerlink" title="⑬Lesson 4 Complete！"></a>⑬Lesson 4 Complete！</h4><p>截至第四课完成，所有代码如下：<br><strong>zombieattack.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiehelper.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieBattle is ZombieHelper &#123;</span><br><span class="line">  uint randNonce = 0;</span><br><span class="line">  uint attackVictoryProbability = 70;</span><br><span class="line"></span><br><span class="line">  function randMod(uint _modulus) internal returns(uint) &#123;</span><br><span class="line">    randNonce++;</span><br><span class="line">    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack(uint _zombieId, uint _targetId) external ownerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    Zombie storage enemyZombie = zombies[_targetId];</span><br><span class="line">    uint rand = randMod(100);</span><br><span class="line">    if (rand &lt;= attackVictoryProbability) &#123;</span><br><span class="line">      myZombie.winCount++;</span><br><span class="line">      myZombie.level++;</span><br><span class="line">      enemyZombie.lossCount++;</span><br><span class="line">      feedAndMultiply(_zombieId, enemyZombie.dna, &quot;zombie&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      myZombie.lossCount++;</span><br><span class="line">      enemyZombie.winCount++;</span><br><span class="line">      _triggerCooldown(myZombie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiehelper.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  uint levelUpFee = 0.001 ether;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() external onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setLevelUpFee(uint _fee) external onlyOwner &#123;</span><br><span class="line">    levelUpFee = _fee;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function levelUp(uint _zombieId) external payable &#123;</span><br><span class="line">    require(msg.value == levelUpFee);</span><br><span class="line">    zombies[_zombieId].level++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) ownerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) ownerOf(_zombieId) &#123;</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefeeding.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  modifier ownerOf(uint _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">      return (_zombie.readyTime &lt;= now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal ownerOf(_zombieId) &#123;</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>zombiefactory.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    uint cooldownTime = 1 days;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">      uint16 winCount;</span><br><span class="line">      uint16 lossCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">    mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime), 0, 0)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        randDna = randDna - randDna % 100;</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ownable.sol:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><h4 id="①第四课-第⑩节"><a href="#①第四课-第⑩节" class="headerlink" title="①第四课 第⑩节"></a>①第四课 第⑩节</h4><p>实战演习中if语句的最后一行<br>feedAndMultiply(_zombieId, enemyZombie.dna, “zombie”);<br>第二个传入’feedAndMultiply’函数的参数<br>为什么是enemyZombie.dna</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>僵尸游戏第二、三课</title>
      <link href="/post/d9a0b533.html"/>
      <url>/post/d9a0b533.html</url>
      
        <content type="html"><![CDATA[<h1 id="三叶草实验室“期末任务”总结（续）-第二课，第三课"><a href="#三叶草实验室“期末任务”总结（续）-第二课，第三课" class="headerlink" title="三叶草实验室“期末任务”总结（续）(第二课，第三课)"></a>三叶草实验室“期末任务”总结（续）(第二课，第三课)</h1><h2 id="任务一：完成加密僵尸的游戏"><a href="#任务一：完成加密僵尸的游戏" class="headerlink" title="任务一：完成加密僵尸的游戏"></a>任务一：完成加密僵尸的游戏</h2><h3 id="2-僵尸攻击人类"><a href="#2-僵尸攻击人类" class="headerlink" title="2.僵尸攻击人类"></a>2.僵尸攻击人类</h3><h4 id="①第二课概览"><a href="#①第二课概览" class="headerlink" title="①第二课概览"></a>①第二课概览</h4><p>僵尸猎食<br>僵尸猎食的时候，僵尸病毒侵入猎物，这些病毒会将猎物变为新的僵尸，加入你的僵尸大军。系统会通 过猎物和猎食者僵尸的DNA计算出新僵尸的DNA。</p><h4 id="②映射（Mapping）和地址（Address）"><a href="#②映射（Mapping）和地址（Address）" class="headerlink" title="②映射（Mapping）和地址（Address）"></a>②映射（Mapping）和地址（Address）</h4><p>我们需要引入2个新的数据类型：mapping（映射） 和 address（地址）。</p><p>Addresses （地址）<br>以太坊区块链由 _ account _ (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 <em>以太</em> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p><p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p><p>0x0cE446255506E92DF41614C46F1d6df9Cc969183</p><p>我们将在后面的课程中介绍地址的细节，现在你只需要了解地址属于特定用户（或智能合约）的。</p><p>所以我们可以指定“地址”作为僵尸主人的 ID。当用户通过与我们的应用程序交互来创建新的僵尸时，新僵尸的所有权被设置到调用者的以太坊地址下。</p><p>Mapping（映射）<br>映射是这样定义的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span><br><span class="line">mapping (address =&gt; uint) public accountBalance;</span><br><span class="line">//或者可以用来通过userId 存储/查找的用户名</span><br><span class="line">mapping (uint =&gt; string) userIdToName;</span><br></pre></td></tr></table></figure><p>映射本质上是存储和查找数据所用的键-值对。在第一个例子中，键是一个 address，值是一个 uint，在第二个例子中，键是一个uint，值是一个 string。</p><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">mapping (address =&gt; uint) ownerZombieCount;</span><br></pre></td></tr></table></figure><h4 id="③Msg-sender"><a href="#③Msg-sender" class="headerlink" title="③Msg.sender"></a>③Msg.sender</h4><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 msg.sender，它指的是当前调用者（或智能合约）的 address。</p><p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 msg.sender总是存在的。</p><p>以下是使用 msg.sender 来更新 mapping 的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line">function setMyNumber(uint _myNumber) public &#123;</span><br><span class="line">  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  // 存储数据至映射的方法和将数据存储在数组相似</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function whatIsMyNumber() public view returns (uint) &#123;</span><br><span class="line">  // 拿到存储在调用者地址名下的值</span><br><span class="line">  // 若调用者还没调用 setMyNumber， 则值为 `0`</span><br><span class="line">  return favoriteNumber[msg.sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个小小的例子中，任何人都可以调用 setMyNumber 在我们的合约中存下一个 uint 并且与他们的地址相绑定。 然后，他们调用 whatIsMyNumber 就会返回他们存储的 uint。</p><p>使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">    uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">    zombieToOwner[id] = msg.sender;</span><br><span class="line">    ownerZombieCount[msg.sender]++;</span><br><span class="line">    NewZombie(id, _name, _dna);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####④Require<br>require使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sayHiToVitalik(string _name) public returns (string) &#123;</span><br><span class="line">  // 比较 _name 是否等于 &quot;Vitalik&quot;. 如果不成立，抛出异常并终止程序</span><br><span class="line">  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span><br><span class="line">  // 两字符串的 keccak256 哈希值来进行判断)</span><br><span class="line">  require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));</span><br><span class="line">  // 如果返回 true, 运行如下语句</span><br><span class="line">  return &quot;Hi!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你这样调用函数 sayHiToVitalik（“Vitalik”） ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p><p>因此，在调用一个函数之前，用 require 验证前置条件是非常有必要的。</p><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>####⑤继承（Inheritance）<br>个让 Solidity 的代码易于管理的功能，就是合约 inheritance (继承)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Doge &#123;</span><br><span class="line">  function catchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;So Wow CryptoDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge &#123;</span><br><span class="line">  function anotherCatchphrase() public returns (string) &#123;</span><br><span class="line">    return &quot;Such Moon BabyDoge&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 BabyDoge 是从 Doge 那里 inherits （继承)过来的。 这意味着当你编译和部署了 BabyDoge，它将可以访问 catchphrase() 和 anotherCatchphrase()和其他我们在 Doge 中定义的其他公共函数。<br>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####⑥引入（Import）<br>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 import 语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;./someothercontract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们在合约（contract）目录下有一个名为 someothercontract.sol 的文件（ .&#x2F; 就是同一目录的意思），它就会被编译器导入。</p><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####⑦Storage与Memory<br>在 Solidity 中，有两个地方可以存储变量 —— storage 或 memory。</p><p>Storage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p><p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p><p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 _ 结构体 _ 和 _ 数组 _ 时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">  struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  function eatSandwich(uint _index) public &#123;</span><br><span class="line">    // Sandwich mySandwich = sandwiches[_index];</span><br><span class="line"></span><br><span class="line">    // ^ 看上去很直接，不过 Solidity 将会给出警告</span><br><span class="line">    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span><br><span class="line"></span><br><span class="line">    // 所以你应该明确定义 `storage`:</span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span><br><span class="line">    // 在存储里，另外...</span><br><span class="line">    mySandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span><br><span class="line"></span><br><span class="line">    // 如果你只想要一个副本，可以使用`memory`:</span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + 1];</span><br><span class="line">    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span><br><span class="line">    // 另外</span><br><span class="line">    anotherSandwich.status = &quot;Eaten!&quot;;</span><br><span class="line">    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span><br><span class="line">    // 不过你可以这样做:</span><br><span class="line">    sandwiches[_index + 1] = anotherSandwich;</span><br><span class="line">    // ...如果你想把副本的改动保存回区块链存储</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还没有完全理解究竟应该使用哪一个,Solidity 编译器会发警示提醒你的。</p><p>实战演示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>####⑧僵尸的DNA<br>获取新的僵尸DNA的公式很简单：计算猎食僵尸DNA和被猎僵尸DNA之间的平均值。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testDnaSplicing() public &#123;</span><br><span class="line">  uint zombieDna = 2222222222222222;</span><br><span class="line">  uint targetDna = 4444444444444444;</span><br><span class="line">  uint newZombieDna = (zombieDna + targetDna) / 2;</span><br><span class="line">  // newZombieDna 将等于 3333333333333333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑨更多关于函数可见性"><a href="#⑨更多关于函数可见性" class="headerlink" title="⑨更多关于函数可见性"></a>⑨更多关于函数可见性</h4><p>internal 和 external<br>除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。</p><p>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</p><p>external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。</p><p>声明函数 internal 或 external 类型的语法，与声明 private 和 public类 型相同：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Sandwich &#123;</span><br><span class="line">  uint private sandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eat() internal &#123;</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich &#123;</span><br><span class="line">  uint private baconSandwichesEaten = 0;</span><br><span class="line"></span><br><span class="line">  function eatWithBacon() public returns (string) &#123;</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    // 因为eat() 是internal 的，所以我们能在这里调用</span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习:将 _createZombie() 函数的属性从 private 改为 internal</p><h4 id="⑩僵尸吃什么"><a href="#⑩僵尸吃什么" class="headerlink" title="⑩僵尸吃什么?"></a>⑩僵尸吃什么?</h4><p>与其他合约的交互：<br>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。</p><p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract LuckyNumber &#123;</span><br><span class="line">  mapping(address =&gt; uint) numbers;</span><br><span class="line"></span><br><span class="line">  function setNum(uint _num) public &#123;</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getNum(address _myAddress) public view returns (uint) &#123;</span><br><span class="line">    return numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p><p>现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。</p><p>首先，我们定义 LuckyNumber 合约的 interface ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p><p>首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。</p><p>其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。</p><p>编译器就是靠这些特征认出它是一个接口的。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑪使用接口"><a href="#⑪使用接口" class="headerlink" title="⑪使用接口"></a>⑪使用接口</h4><p>继续前面 NumberInterface 的例子，我们既然将接口定义为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  function getNum(address _myAddress) public view returns (uint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在合约中这样使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract MyContract &#123;</span><br><span class="line">  address NumberInterfaceAddress = 0xab38...;</span><br><span class="line">  // ^ 这是FavoriteNumber合约在以太坊上的地址</span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  // 现在变量 `numberContract` 指向另一个合约对象</span><br><span class="line"></span><br><span class="line">  function someFunction() public &#123;</span><br><span class="line">    // 现在我们可以调用在那个合约中声明的 `getNum`函数:</span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    // ...在这儿使用 `num`变量做些什么</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，只要将您合约的可见性设置为public(公共)或external(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KittyInterface kittyContract = KittyInterface(ckAddress);</span><br></pre></td></tr></table></figure><h4 id="⑫处理多返回值"><a href="#⑫处理多返回值" class="headerlink" title="⑫处理多返回值"></a>⑫处理多返回值</h4><p>getKitty 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function multipleReturns() internal returns(uint a, uint b, uint c) &#123;</span><br><span class="line">  return (1, 2, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processMultipleReturns() external &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  // 这样来做批量赋值:</span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者如果我们只想返回其中一个变量:</span><br><span class="line">function getLastReturnValue() external &#123;</span><br><span class="line">  uint c;</span><br><span class="line">  // 可以对其他字段留空:</span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战演习:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    // 并修改函数调用</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑬奖励-Kitty-基因"><a href="#⑬奖励-Kitty-基因" class="headerlink" title="⑬奖励: Kitty 基因"></a>⑬奖励: Kitty 基因</h4><p>还记得吗，第一课中我们提到，我们目前只使用16位DNA的前12位数来指定僵尸的外观。所以现在我们可以使用最后2个数字来处理“特殊”的特征。</p><p>这样吧，把猫僵尸DNA的最后两个数字设定为99（因为猫有9条命）。所以在我们这么来写代码：如果这个僵尸是一只猫变来的，就将它DNA的最后两位数字设置为99。</p><p>if 语句<br>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function eatBLT(string sandwich) public &#123;</span><br><span class="line">  // 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span><br><span class="line">  if (keccak256(sandwich) == keccak256(&quot;BLT&quot;)) &#123;</span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑭放在一起"><a href="#⑭放在一起" class="headerlink" title="⑭放在一起"></a>⑭放在一起</h4><p>JavaScript 实现<br>我们只用编译和部署 ZombieFeeding，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 ZombieFactory，因此它可以访问自己和父辈合约中的所有 public 方法。</p><p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var abi = /* abi generated by the compiler */</span><br><span class="line">var ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* our contract address on Ethereum after deploying */</span><br><span class="line">var ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span><br><span class="line">let zombieId = 1;</span><br><span class="line">let kittyId = 1;</span><br><span class="line"></span><br><span class="line">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span><br><span class="line">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span><br><span class="line">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span><br><span class="line">let apiUrl = &quot;https://api.cryptokitties.co/kitties/&quot; + kittyId</span><br><span class="line">$.get(apiUrl, function(data) &#123;</span><br><span class="line">  let imgUrl = data.image_url</span><br><span class="line">  // 一些显示图片的代码</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 当用户点击一只猫咪的时候:</span><br><span class="line">$(&quot;.kittyImage&quot;).click(function(e) &#123;</span><br><span class="line">  // 调用我们合约的 `feedOnKitty` 函数</span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 侦听来自我们合约的新僵尸事件好来处理</span><br><span class="line">ZombieFactory.NewZombie(function(error, result) &#123;</span><br><span class="line">  if (error) return</span><br><span class="line">  // 这个函数用来显示僵尸:</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="⑮第二课完成"><a href="#⑮第二课完成" class="headerlink" title="⑮第二课完成"></a>⑮第二课完成</h4><p>截至第二课完成，所有代码如下：<br>zombiefactory.sol</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">    mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        randDna = randDna - randDna % 100;</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zombiefeeding.sol</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;</span><br><span class="line">  KittyInterface kittyContract = KittyInterface(ckAddress);</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-高级-Solidity-理论"><a href="#3-高级-Solidity-理论" class="headerlink" title="3.高级 Solidity 理论"></a>3.高级 Solidity 理论</h3><h4 id="①智能协议的永固性"><a href="#①智能协议的永固性" class="headerlink" title="①智能协议的永固性"></a>①智能协议的永固性</h4><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p><p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p><p>第一个例子，在你把智能协议传上以太坊之后，它就变得不可更改, 这种永固性意味着你的代码永远不能被调整或更新。</p><p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p><p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p><p>外部依赖关系：<br>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p><p>因此，我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p><p>比方说，我们不再一开始就把猎物地址给写入代码，而是写个函数 setKittyContractAddress, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p><p>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="②Ownable-Contracts"><a href="#②Ownable-Contracts" class="headerlink" title="②Ownable Contracts"></a>②Ownable Contracts</h4><p>OpenZeppelin库的Ownable 合约<br>下面是一个 Ownable 合约的例子： 来自 _ OpenZeppelin _ Solidity 库的 Ownable 合约。 OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看，保管您会学到很多东西！</p><p>把楼下这个合约读读通，是不是还有些没见过代码？别担心，我们随后会解释。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造函数：function Ownable()是一个 _ constructor_ (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li><li>函数修饰符：modifier onlyOwner()。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 onlyOwner 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的_;。</li><li>indexed 关键字：别担心，我们还用不到它。</li></ol><p>所以Ownable 合约基本都会这么干：</p><ol><li>合约创建，构造函数先行，将其 owner 设置为msg.sender（其部署者）</li><li>为它加上一个修饰符 onlyOwner，它会限制陌生人的访问，将访问某些函数的权限锁定在 owner 上。</li><li>允许将合约所有权转让给他人。</li></ol><p>onlyOwner 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制&#x2F;粘贴 Ownable 开始的，从它再继承出的子类，并在之上进行功能开发。</p><p>既然我们想把 setKittyContractAddress 限制为 onlyOwner ，我们也要做同样的事情。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br></pre></td></tr></table></figure><h4 id="③onlyOwner-函数修饰符"><a href="#③onlyOwner-函数修饰符" class="headerlink" title="③onlyOwner 函数修饰符"></a>③onlyOwner 函数修饰符</h4><p>现在我们有了个基本版的合约 ZombieFactory 了，它继承自 Ownable 接口，我们也可以给 ZombieFeeding 加上 onlyOwner 函数修饰符。</p><p>这就是合约继承的工作原理。记得：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZombieFeeding 是个 ZombieFactory</span><br><span class="line">ZombieFactory 是个 Ownable</span><br></pre></td></tr></table></figure><p>因此 ZombieFeeding 也是个 Ownable, 并可以通过 Ownable 接口访问父类中的函数&#x2F;事件&#x2F;修饰符。往后，ZombieFeeding 的继承者合约们同样也可以这么延续下去。</p><p><strong>函数修饰符</strong><br>函数修饰符看起来跟函数没什么不同，不过关键字modifier 告诉编译器，这是个modifier(修饰符)，而不是个function(函数)。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p><p>咱们仔细读读 onlyOwner:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev 调用者不是‘主人’，就会抛出异常</span><br><span class="line"> */</span><br><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">  require(msg.sender == owner);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onlyOwner 函数修饰符是这么用的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  //注意！ `onlyOwner`上场 :</span><br><span class="line">  function likeABoss() external onlyOwner &#123;</span><br><span class="line">    LaughManiacally(&quot;Muahahahaha&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 likeABoss 函数上的 onlyOwner 修饰符。 当你调用 likeABoss 时，首先执行 onlyOwner 中的代码， 执行到 onlyOwner 中的 _; 语句时，程序再返回并执行 likeABoss 中的代码。</p><p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 require检查。</p><p>因为给函数添加了修饰符 onlyOwner，使得唯有合约的主人（也就是部署者）才能调用它。</p><blockquote><p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p></blockquote><blockquote><p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。<br>实战演习：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改这个函数:</span><br><span class="line">function setKittyContractAddress(address _address) external &#123;</span><br><span class="line">//修改后：</span><br><span class="line">function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br></pre></td></tr></table></figure><h4 id="④Gas"><a href="#④Gas" class="headerlink" title="④Gas"></a>④Gas</h4><p><strong>Gas - 驱动以太坊DApps的能源</strong><br>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 gas，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p><p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 gas 等于这个操作背后的所有运算花销的总和。</p><p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来，运行花费更高，这显然会给成千上万的用户带来大量不必要的开销。<br><strong>为什么要用 gas 来驱动？</strong><br>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p><p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p><blockquote><p>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</p></blockquote><p><strong>省 gas 的招数：结构封装 （Struct packing）</strong><br>在第1课中，我们提到除了基本版的 uint 外，还有其他变种 uint：uint8，uint16，uint32等。</p><p>通常情况下我们不会考虑使用 uint 变种，因为无论如何定义 uint的大小，Solidity 为它保留256位的存储空间。例如，使用 uint8 而不是uint（uint256）不会为你节省任何 gas。</p><p>除非，把 uint 绑定到 struct 里面。</p><p>如果一个 struct 中有多个 uint，则尽可能使用较小的 uint, Solidity 会将这些 uint 打包在一起，从而占用较少的存储空间。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span><br><span class="line">NormalStruct normal = NormalStruct(10, 20, 30);</span><br><span class="line">MiniMe mini = MiniMe(10, 20, 30); </span><br></pre></td></tr></table></figure><p>所以，当 uint 定义在一个 struct 中的时候，尽量使用最小的整数子类型以节约空间。 并且把同样类型的变量放一起（即在 struct 中将把变量按照类型依次放置），这样 Solidity 可以将存储空间最小化。例如，有两个 struct：</p><p>uint c; uint32 a; uint32 b; 和 uint32 a; uint c; uint32 b;</p><p>前者比后者需要的gas更少，因为前者把uint32放一起了。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">        uint32 level;</span><br><span class="line">        uint32 readyTime;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="⑤时间单位"><a href="#⑤时间单位" class="headerlink" title="⑤时间单位"></a>⑤时间单位</h4><p>level 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p><p>readyTime 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p><p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。<br><strong>时间单位</strong><br>Solidity 使用自己的本地时间单位。</p><p>变量 now 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 1515527488。</p><blockquote><p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p></blockquote><p>Solidity 还包含秒(seconds)，分钟(minutes)，小时(hours)，天(days)，周(weeks) 和 年(years) 等时间单位。它们都会转换成对应的秒数放入 uint 中。所以 1分钟 就是 60，1小时是 3600（60秒×60分钟），1天是86400（24小时×60分钟×60秒），以此类推。</p><p>下面是一些使用时间单位的实用案例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line">// 将‘上次更新时间’ 设置为 ‘现在’</span><br><span class="line">function updateTimestamp() public &#123;</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果到上次`updateTimestamp` 超过5分钟，返回 &#x27;true&#x27;</span><br><span class="line">// 不到5分钟返回 &#x27;false&#x27;</span><br><span class="line">function fiveMinutesHavePassed() public view returns (bool) &#123;</span><br><span class="line">  return (now &gt;= (lastUpdated + 5 minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 在这里定义 `cooldownTime`</span><br><span class="line"></span><br><span class="line">// 2. 修改下面这行:</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">// uint cooldownTime = 1 days;</span><br><span class="line">   uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br></pre></td></tr></table></figure><h4 id="⑥僵尸冷却"><a href="#⑥僵尸冷却" class="headerlink" title="⑥僵尸冷却"></a>⑥僵尸冷却</h4><p>现在，Zombie 结构体中定义好了一个 readyTime 属性，让我们跳到 zombiefeeding.sol， 去实现一个”冷却周期定时器“。</p><p>按照以下步骤修改 feedAndMultiply：</p><ol><li>”捕猎“行为会触发僵尸的”冷却周期“</li><li>僵尸在这段”冷却周期“结束前不可再捕猎小猫</li></ol><p>这将限制僵尸，防止其无限制地捕猎小猫或者整天不停地繁殖。将来，当我们增加战斗功能时，我们同样用”冷却周期“限制僵尸之间打斗的频率。</p><p>首先，我们要定义一些辅助函数，设置并检查僵尸的 readyTime。<br><strong>将结构体作为参数传入</strong><br>由于结构体的存储指针可以以参数的方式传递给一个 private 或 internal 的函数，因此结构体可以在多个函数之间相互传递。</p><p>遵循这样的语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _doStuff(Zombie storage _zombie) internal &#123;</span><br><span class="line">  // do stuff with _zombie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">  _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">    return (_zombie.readyTime &lt;= now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑦公有函数和安全性"><a href="#⑦公有函数和安全性" class="headerlink" title="⑦公有函数和安全性"></a>⑦公有函数和安全性</h4><p>现在来修改 feedAndMultiply ，实现冷却周期。</p><p>回顾一下这个函数，前一课上我们将其可见性设置为public。你必须仔细地检查所有声明为 public 和 external的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 onlyOwner 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p><p>检查完这个函数，用户就可以直接调用这个它，并传入他们所希望的 _targetDna 或 species 。</p><p>仔细观察，这个函数只需被 feedOnKitty() 调用，因此，想要防止漏洞，最简单的方法就是设其可见性为 internal。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 使这个函数的可见性为 internal</span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string species) internal &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));// 2. 在这里为 `_isReady` 增加一个检查</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);// 3. 调用 `_triggerCooldown`</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑧进一步了解函数修饰符"><a href="#⑧进一步了解函数修饰符" class="headerlink" title="⑧进一步了解函数修饰符"></a>⑧进一步了解函数修饰符</h4><p><strong>带参数的函数修饰符</strong><br>之前我们已经读过一个简单的函数修饰符了：onlyOwner。函数修饰符也可以带参数。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 存储用户年龄的映射</span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line">// 限定用户年龄的修饰符</span><br><span class="line">modifier olderThan(uint _age, uint _userId) &#123;</span><br><span class="line">  require(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span><br><span class="line">// 我们可以用如下参数调用`olderThan` 修饰符:</span><br><span class="line">function driveCar(uint _userId) public olderThan(16, _userId) &#123;</span><br><span class="line">  // 其余的程序逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧， olderThan 修饰符可以像函数一样接收参数，是“宿主”函数 driveCar 把参数传递给它的修饰符的。</p><p>来，我们自己生产一个修饰符，通过传入的level参数来限制僵尸使用某些特殊功能。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑨僵尸修饰符"><a href="#⑨僵尸修饰符" class="headerlink" title="⑨僵尸修饰符"></a>⑨僵尸修饰符</h4><p>现在让我们设计一些使用 aboveLevel 修饰符的函数。</p><p>作为游戏，您得有一些措施激励玩家们去升级他们的僵尸：</p><ul><li>2级以上的僵尸，玩家可给他们改名。</li><li>20级以上的僵尸，玩家能给他们定制的 DNA。</li></ul><p>是实现这些功能的时候了。以下是上一课的示例代码，供参考：（第八节课的代码）<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑩利用-‘View’-函数节省-Gas"><a href="#⑩利用-‘View’-函数节省-Gas" class="headerlink" title="⑩利用 ‘View’ 函数节省 Gas"></a>⑩利用 ‘View’ 函数节省 Gas</h4><p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 getZombiesByOwner。</p><p>实现这个功能只需从区块链中读取数据，所以它可以是一个 view 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p><p><strong>“view” 函数不花 “gas”</strong><br>当玩家从外部调用一个view函数，是不需要支付一分 gas 的。</p><p>这是因为 view 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 view 标记一个函数，意味着告诉 web3.js，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p><p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“external view 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p><blockquote><p>注意：如果一个 view 函数在另一个函数的内部被调用，而调用函数与 view 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 view 的函数只有在外部调用时才是免费的。<br>实战演习：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑪存储非常昂贵"><a href="#⑪存储非常昂贵" class="headerlink" title="⑪存储非常昂贵"></a>⑪存储非常昂贵</h4><p>Solidity 使用storage(存储)是相当昂贵的，”写入“操作尤其贵。</p><p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p><p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 memory(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p><p>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了external view的函数，遍历比 storage 要便宜太多，因为 view 函数不会产生任何花销。</p><p>我们将在下一章讨论for循环，现在我们来看一下看如何如何在内存中声明数组。</p><p><strong>在内存中声明数组</strong><br>在数组后面加上 memory关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 storage 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在view里用，完全不用花钱。</p><p>以下是申明一个内存数组的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getArray() external pure returns(uint[]) &#123;</span><br><span class="line">  // 初始化一个长度为3的内存数组</span><br><span class="line">  uint[] memory values = new uint[](3);</span><br><span class="line">  // 赋值</span><br><span class="line">  values.push(1);</span><br><span class="line">  values.push(2);</span><br><span class="line">  values.push(3);</span><br><span class="line">  // 返回数组</span><br><span class="line">  return values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 for 循环结合的做法。</p><blockquote><p>注意：内存数组 必须 用长度参数（在本例中为3）创建。目前不支持 array.push()之类的方法调整数组大小，在未来的版本可能会支持长度修改。<br>实战演习：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑫For循环"><a href="#⑫For循环" class="headerlink" title="⑫For循环"></a>⑫For循环</h4><p>在之前的章节中，我们提到过，函数中使用的数组是运行时在内存中通过 for 循环实时构建，而不是预先建立在存储中的。</p><p>为什么要这样做呢？</p><p>为了实现 getZombiesByOwner 函数，一种“无脑式”的解决方案是在 ZombieFactory 中存入”主人“和”僵尸军团“的映射。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; uint[]) public ownerToZombies</span><br></pre></td></tr></table></figure><p>然后我们每次创建新僵尸时，执行 ownerToZombies [owner] .push（zombieId） 将其添加到主人的僵尸数组中。而 getZombiesByOwner 函数也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns (uint[]) &#123;</span><br><span class="line">  return ownerToZombies[_owner];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个做法有问题</strong><br>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p><p>这个“换主”函数要做到：</p><p>1.将僵尸push到新主人的 ownerToZombies 数组中， 2.从旧主的 ownerToZombies 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p><p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p><p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p><blockquote><p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p></blockquote><p>由于从外部调用一个 view 函数是免费的，我们也可以在 getZombiesByOwner 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 transfer 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p><p><strong>使用 for 循环</strong><br>for循环的语法在 Solidity 和 JavaScript 中类似。</p><p>来看一个创建偶数数组的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getEvens() pure external returns(uint[]) &#123;</span><br><span class="line">  uint[] memory evens = new uint[](5);</span><br><span class="line">  // 在新数组中记录序列号</span><br><span class="line">  uint counter = 0;</span><br><span class="line">  // 在循环从1迭代到10：</span><br><span class="line">  for (uint i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    // 如果 `i` 是偶数...</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">      // 把它加入偶数数组</span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      //索引加一， 指向下一个空的‘even’</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return evens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数将返回一个形为 [2,4,6,8,10] 的数组。<br>实战演习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="⑬放在一起"><a href="#⑬放在一起" class="headerlink" title="⑬放在一起"></a>⑬放在一起</h4><p><strong>让我们回顾一下：</strong></p><ul><li>添加了一种新方法来修改CryptoKitties合约</li><li>学会使用 onlyOwner 进行调用权限限制</li><li>了解了 gas 和 gas 的优化</li><li>为僵尸添加了 “级别” 和 “冷却周期”属性</li><li>当僵尸达到一定级别时，允许修改僵尸的名字和 DNA</li><li>最后，定义了一个函数，用以返回某个玩家的僵尸军团</li></ul><h4 id="⑭第三课完成"><a href="#⑭第三课完成" class="headerlink" title="⑭第三课完成"></a>⑭第三课完成</h4><p>截至第三课完成，所有代码如下：<br>zombiehelper.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefeeding.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieHelper is ZombieFeeding &#123;</span><br><span class="line"></span><br><span class="line">  modifier aboveLevel(uint _level, uint _zombieId) &#123;</span><br><span class="line">    require(zombies[_zombieId].level &gt;= _level);</span><br><span class="line">    _;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].name = _newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    zombies[_zombieId].dna = _newDna;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getZombiesByOwner(address _owner) external view returns(uint[]) &#123;</span><br><span class="line">    uint[] memory result = new uint[](ownerZombieCount[_owner]);</span><br><span class="line">    uint counter = 0;</span><br><span class="line">    for (uint i = 0; i &lt; zombies.length; i++) &#123;</span><br><span class="line">      if (zombieToOwner[i] == _owner) &#123;</span><br><span class="line">        result[counter] = i;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zombiefeeding.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./zombiefactory.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract KittyInterface &#123;</span><br><span class="line">  function getKitty(uint256 _id) external view returns (</span><br><span class="line">    bool isGestating,</span><br><span class="line">    bool isReady,</span><br><span class="line">    uint256 cooldownIndex,</span><br><span class="line">    uint256 nextActionAt,</span><br><span class="line">    uint256 siringWithId,</span><br><span class="line">    uint256 birthTime,</span><br><span class="line">    uint256 matronId,</span><br><span class="line">    uint256 sireId,</span><br><span class="line">    uint256 generation,</span><br><span class="line">    uint256 genes</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ZombieFeeding is ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">  KittyInterface kittyContract;</span><br><span class="line"></span><br><span class="line">  function setKittyContractAddress(address _address) external onlyOwner &#123;</span><br><span class="line">    kittyContract = KittyInterface(_address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _triggerCooldown(Zombie storage _zombie) internal &#123;</span><br><span class="line">    _zombie.readyTime = uint32(now + cooldownTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _isReady(Zombie storage _zombie) internal view returns (bool) &#123;</span><br><span class="line">      return (_zombie.readyTime &lt;= now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal &#123;</span><br><span class="line">    require(msg.sender == zombieToOwner[_zombieId]);</span><br><span class="line">    Zombie storage myZombie = zombies[_zombieId];</span><br><span class="line">    require(_isReady(myZombie));</span><br><span class="line">    _targetDna = _targetDna % dnaModulus;</span><br><span class="line">    uint newDna = (myZombie.dna + _targetDna) / 2;</span><br><span class="line">    if (keccak256(_species) == keccak256(&quot;kitty&quot;)) &#123;</span><br><span class="line">      newDna = newDna - newDna % 100 + 99;</span><br><span class="line">    &#125;</span><br><span class="line">    _createZombie(&quot;NoName&quot;, newDna);</span><br><span class="line">    _triggerCooldown(myZombie);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function feedOnKitty(uint _zombieId, uint _kittyId) public &#123;</span><br><span class="line">    uint kittyDna;</span><br><span class="line">    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);</span><br><span class="line">    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zombiefactory.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">import &quot;./ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory is Ownable &#123;</span><br><span class="line"></span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    uint cooldownTime = 1 days;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">      string name;</span><br><span class="line">      uint dna;</span><br><span class="line">      uint32 level;</span><br><span class="line">      uint32 readyTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    mapping (uint =&gt; address) public zombieToOwner;</span><br><span class="line">    mapping (address =&gt; uint) ownerZombieCount;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) internal &#123;</span><br><span class="line">        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;</span><br><span class="line">        zombieToOwner[id] = msg.sender;</span><br><span class="line">        ownerZombieCount[msg.sender]++;</span><br><span class="line">        NewZombie(id, _name, _dna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        require(ownerZombieCount[msg.sender] == 0);</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        randDna = randDna - randDna % 100;</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ownable.sol:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @title Ownable</span><br><span class="line"> * @dev The Ownable contract has an owner address, and provides basic authorization control</span><br><span class="line"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span><br><span class="line"> */</span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev The Ownable constructor sets the original `owner` of the contract to the sender</span><br><span class="line">   * account.</span><br><span class="line">   */</span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Throws if called by any account other than the owner.</span><br><span class="line">   */</span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Allows the current owner to transfer control of the contract to a newOwner.</span><br><span class="line">   * @param newOwner The address to transfer ownership to.</span><br><span class="line">   */</span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner != address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="心得-①-②-③-④-⑤-⑥-⑦-⑧-⑨-⑩-⑪-⑫-⑬-⑭-⑮-⑯-⑰-⑱-⑲-⑳"><a href="#心得-①-②-③-④-⑤-⑥-⑦-⑧-⑨-⑩-⑪-⑫-⑬-⑭-⑮-⑯-⑰-⑱-⑲-⑳" class="headerlink" title="心得 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳"></a>心得 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳</h3><h4 id="①第二课-第7节Storage与Memory"><a href="#①第二课-第7节Storage与Memory" class="headerlink" title="①第二课 第7节Storage与Memory"></a>①第二课 第7节Storage与Memory</h4><p>实战演习代码的第三行<br>require(msg.sender &#x3D;&#x3D; zombieToOwner[_zombieId]);<br>&#x3D;&#x3D; 后面为什么是 zombieToOwner[_zombieId]);<br>而不是 _zombieId</p><h4 id="②第二课-第3节Msg-sender"><a href="#②第二课-第3节Msg-sender" class="headerlink" title="②第二课 第3节Msg.sender"></a>②第二课 第3节Msg.sender</h4><p>实战演习中<br>    zombieToOwner[id] &#x3D; msg.sender;<br>    ownerZombieCount[msg.sender]++;<br>的这两句代码无法理解</p><h4 id="③第一课-第8节"><a href="#③第一课-第8节" class="headerlink" title="③第一课 第8节"></a>③第一课 第8节</h4><p>游戏第一课的第八小节的实战演习中<br>误把 zombies.push(Zombie(_name, _dna)); 写成了zombies.push(Zombie(name, dna));</p><h4 id="④第一课-第9节"><a href="#④第一课-第9节" class="headerlink" title="④第一课 第9节"></a>④第一课 第9节</h4><p>游戏第一课的第九小节的实战演习中<br>误把 function createZombie(string _name, uint _dna) private {; 写成了function _createZombie(string _name, uint <em>dna) private {;</em></p><h4 id="⑤第一课-第11节"><a href="#⑤第一课-第11节" class="headerlink" title="⑤第一课 第11节"></a>⑤第一课 第11节</h4><p>游戏第一课的第十一小节的实战演习中 把uint rand &#x3D; uint(keccak256(_str));<br>写成了uint rand &#x3D; (uint)keccak256(_str);</p><h4 id="⑥第二课第6节"><a href="#⑥第二课第6节" class="headerlink" title="⑥第二课第6节"></a>⑥第二课第6节</h4><p>‘_isReady’函数里为什么是’return (_zombie.readyTime &lt;&#x3D; now);’<br>而不是’require(_zombie.readyTime &lt;&#x3D; now);’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语言学习</title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="RUNOOB-Markdown-Test学习"><a href="#RUNOOB-Markdown-Test学习" class="headerlink" title="RUNOOB Markdown Test学习"></a>RUNOOB Markdown Test学习</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><h1 id="标题格式："><a href="#标题格式：" class="headerlink" title="标题格式："></a>标题格式：</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h1 id="字体格式："><a href="#字体格式：" class="headerlink" title="字体格式："></a>字体格式：</h1><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h1 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h1><hr><hr><hr><hr><hr><h1 id="删除线："><a href="#删除线：" class="headerlink" title="删除线："></a>删除线：</h1><p>RUNOOB.COM<br>GOOGLE.COM<br><del>BAIDU.COM</del></p><h1 id="下划线："><a href="#下划线：" class="headerlink" title="下划线："></a>下划线：</h1><p><u>带下划线文本</u></p><h1 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h1><p>脚注格式：[^要注明的文本]<br>创建脚注格式类似这样 [^创建]。</p><p>[^创建]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h1 id="无序列表（三种形式都可以）："><a href="#无序列表（三种形式都可以）：" class="headerlink" title="无序列表（三种形式都可以）："></a>无序列表（三种形式都可以）：</h1><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h1 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h1><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h1 id="列表嵌套（需要在子列表的前面加四个空格）："><a href="#列表嵌套（需要在子列表的前面加四个空格）：" class="headerlink" title="列表嵌套（需要在子列表的前面加四个空格）："></a>列表嵌套（需要在子列表的前面加四个空格）：</h1><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="区块（-gt-后面需要加一个空格）："><a href="#区块（-gt-后面需要加一个空格）：" class="headerlink" title="区块（&gt;后面需要加一个空格）："></a>区块（&gt;后面需要加一个空格）：</h1><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><h2 id="区块嵌套："><a href="#区块嵌套：" class="headerlink" title="区块嵌套："></a>区块嵌套：</h2><blockquote><p>最外层</p><blockquote><p>第一层嵌套<br>111</p><blockquote><p>第二层嵌套<br>222</p></blockquote></blockquote></blockquote><h2 id="区块中使用列表："><a href="#区块中使用列表：" class="headerlink" title="区块中使用列表："></a>区块中使用列表：</h2><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="列表中使用区块："><a href="#列表中使用区块：" class="headerlink" title="列表中使用区块："></a>列表中使用区块：</h2><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p><code>printf()</code> 函数<br><code>System.out.println()</code> 函数</p><h2 id="代码区块-代码区块使用-4-个空格或者一个制表符（Tab-键）。-："><a href="#代码区块-代码区块使用-4-个空格或者一个制表符（Tab-键）。-：" class="headerlink" title="代码区块(代码区块使用 4 个空格或者一个制表符（Tab 键）。)："></a>代码区块(代码区块使用 4 个空格或者一个制表符（Tab 键）。)：</h2><pre><code>System.out.println()public classpublic static void main</code></pre><h2 id="你也可以用-96-96-96-包裹一段代码，并指定一种语言（也可以不指定）："><a href="#你也可以用-96-96-96-包裹一段代码，并指定一种语言（也可以不指定）：" class="headerlink" title="你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）："></a>你也可以用 &#96;&#96;&#96; 包裹一段代码，并指定一种语言（也可以不指定）：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h1><p>第一种形式：<a href="https://www.runoob.com/">https://www.runoob.com</a><br>第二种形式：这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><h2 id="高级链接（感觉没太大用处）："><a href="#高级链接（感觉没太大用处）：" class="headerlink" title="高级链接（感觉没太大用处）："></a>高级链接（感觉没太大用处）：</h2><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>语法格式：<br><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p><p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"></p><ol><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的<br>‘title’ 属性的文字。</li></ol><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"><br>也可以像网址那样对图片网址使用变量:</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><img src="http://static.runoob.com/images/runoob-logo.png" width="50%"><h1 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>语法格式如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式：我们可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>实例如下：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格11111</td><td align="right">单元格11111</td><td align="center">单元格11111111111</td></tr><tr><td align="left">单元格222222</td><td align="right">单元格222222222</td><td align="center">单元格22</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
